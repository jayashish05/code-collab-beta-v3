<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= title %></title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- CodeMirror CSS (fallback) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/theme/dracula.min.css">
  <!-- Spline Viewer -->
  <!-- Include project styles -->
  <%- include('style1.ejs') %>
  <%- include('style2.ejs') %>

  <script>
    console.log('ENHANCED ROOM LAYOUT LOADED - <%= new Date().toISOString() %>');
  </script>

  <style>
    /* Room Page Specific Styles */
    body {
      overflow: hidden;
      height: 100vh;
      position: relative;
    }

    /* Spline Background Container */
    .spline-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      overflow: hidden;
      opacity: 0.4;
      filter: brightness(0.4) contrast(1.1) saturate(1.2);
      transition: opacity 0.5s ease;
    }

    /* Fallback gradient background */
    .gradient-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      background: linear-gradient(125deg, #0a2463, #3e92cc, #2a628f, #3e92cc);
      background-size: 400% 400%;
      animation: gradientBG 15s ease infinite;
      opacity: 0.3;
      transition: opacity 0.5s ease, z-index 0.1s;
      pointer-events: none;
    }

    @keyframes gradientBG {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .room-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      position: relative;
      z-index: 1;
      background-color: rgba(15, 15, 25, 0.9);
      backdrop-filter: blur(15px);
      padding-bottom: 40px; /* Account for footer */
    }

    body:not(.dark-mode) .room-container {
      background-color: rgba(255, 255, 255, 0.7);
    }

    .top-navbar {
      padding: 0.5rem 1rem;
      background-color: rgba(20, 20, 30, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(70, 70, 90, 0.5);
      z-index: 100;
      color: #e0e0e0;
    }

    .room-name {
      font-weight: 600;
      margin-right: 1rem;
    }

    .room-name[contenteditable="true"]:focus {
      outline: none;
      border-bottom: 2px solid var(--ios-primary);
      padding-bottom: 2px;
    }

    .user-avatars {
      display: flex;
      align-items: center;
    }

    .avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid white;
      margin-left: -10px;
      background-color: var(--ios-gray-3);
      overflow: hidden;
      position: relative;
    }

    .avatar:first-child {
      margin-left: 0;
    }

    .avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .avatar .online-indicator {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: var(--ios-success);
      border: 1px solid white;
    }

    .main-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .sidebar {
      width: 250px;
      background-color: rgba(25, 25, 35, 0.95);
      backdrop-filter: blur(5px);
      border-right: 1px solid rgba(70, 70, 90, 0.5);
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    body:not(.dark-mode) .sidebar {
      background-color: rgba(248, 249, 250, 0.8);
    }

    .sidebar-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--ios-gray-1);
      color: #c0c0c0;
    }

    .file-actions .btn {
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
    }

    .files-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .files-list li {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid rgba(70, 70, 90, 0.3);
      color: #e0e0e0;
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
    }

    .files-list li:hover {
      background-color: rgba(60, 60, 80, 0.5);
    }

    .files-list li.active {
      background-color: rgba(0, 122, 255, 0.3);
      color: #ffffff;
      border-left: 3px solid #007aff;
      padding-left: calc(1rem - 3px);
    }

    .file-icon {
      margin-right: 0.5rem;
      color: #a0a0a0;
    }

    .monaco-editor-container {
      flex: 1;
      overflow: hidden;
      position: relative;
      min-height: 300px;
      display: flex;
    }

    /* Force editor background color */
    .monaco-editor .monaco-editor-background,
    .monaco-editor .margin {
      background-color: rgba(20, 20, 25, 0.95) !important;
    }

    body:not(.dark-mode) .monaco-editor .monaco-editor-background,
    body:not(.dark-mode) .monaco-editor .margin {
      background-color: rgba(255, 255, 255, 0.7) !important;
    }

    #monaco-editor {
      width: 100%;
      height: 100%;
      min-height: 300px;
    }

    .bottom-panel {
      height: 250px;
      display: flex;
      border-top: 1px solid rgba(70, 70, 90, 0.5);
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
    }

    .terminal {
      flex: 1;
      background-color: rgba(15, 15, 20, 0.98);
      color: #f0f0f0;
      font-family: 'Consolas', 'Monaco', monospace;
      padding: 0.5rem;
      overflow-y: auto;
    }

    .terminal-input {
      display: flex;
      background-color: transparent;
      border-top: 1px solid #333;
      padding: 0.5rem 0;
    }

    .terminal-input-prompt {
      color: #00b8d4;
      margin-right: 0.5rem;
    }

    .terminal-input-field {
      flex: 1;
      background-color: transparent;
      border: none;
      color: #f0f0f0;
      font-family: 'Consolas', 'Monaco', monospace;
      outline: none;
    }

    /* Footer Section */
    .footer-section {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40px;
      background-color: rgba(25, 25, 35, 0.98);
      border-top: 1px solid rgba(70, 70, 90, 0.5);
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }

    body:not(.dark-mode) .footer-section {
      background-color: rgba(240, 240, 240, 0.98);
      color: #333;
    }

    .footer-left {
      display: flex;
      align-items: center;
      gap: 15px;
      font-size: 0.85rem;
      color: #a0a0a0;
    }

    body:not(.dark-mode) .footer-left {
      color: #666;
    }

    .footer-right {
      display: flex;
      gap: 10px;
    }

    .footer-btn {
      background: none;
      border: none;
      color: #a0a0a0;
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 4px;
      transition: all 0.2s ease;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .footer-btn:hover {
      background-color: rgba(60, 60, 80, 0.5);
      color: #fff;
    }

    .footer-btn.active {
      background-color: rgba(0, 122, 255, 0.3);
      color: #fff;
    }

    body:not(.dark-mode) .footer-btn {
      color: #666;
    }

    body:not(.dark-mode) .footer-btn:hover {
      background-color: rgba(200, 200, 200, 0.5);
      color: #333;
    }

    /* Voice Chat Button States */
    .footer-btn.voice-connected {
      background: #28a745 !important;
      color: white !important;
    }

    .footer-btn.voice-muted {
      background: #dc3545 !important;
      color: white !important;
    }

    .footer-btn.voice-deafened {
      background: #ffc107 !important;
      color: #212529 !important;
    }

    body:not(.dark-mode) .footer-btn.voice-connected:hover,
    body:not(.dark-mode) .footer-btn.voice-muted:hover,
    body:not(.dark-mode) .footer-btn.voice-deafened:hover {
      opacity: 0.8 !important;
    }

    /* Voice Chat Participants Indicator */
    #voice-participants-indicator {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #28a745;
      color: white;
      border-radius: 50%;
      width: 18px;
      height: 18px;
      font-size: 11px;
      display: none;
      align-items: center;
      justify-content: center;
    }

    /* Voice Chat Button States */
    .footer-btn.voice-connected {
      background: #28a745;
      color: white;
    }

    .footer-btn.voice-muted {
      background: #dc3545;
      color: white;
    }

    .footer-btn.voice-deafened {
      background: #ffc107;
      color: #212529;
    }

    body:not(.dark-mode) .footer-btn.voice-connected:hover,
    body:not(.dark-mode) .footer-btn.voice-muted:hover,
    body:not(.dark-mode) .footer-btn.voice-deafened:hover {
      opacity: 0.8;
    }

    /* Voice Chat Participants Indicator */
    #voice-participants-indicator {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #28a745;
      color: white;
      border-radius: 50%;
      width: 18px;
      height: 18px;
      font-size: 11px;
      display: none;
      align-items: center;
      justify-content: center;
    }

    /* Slide-in Chat Panel (VS Code style) */
    .chat-sidebar {
      position: fixed;
      top: 0;
      right: -400px;
      width: 400px;
      height: 100vh;
      background-color: rgba(25, 25, 35, 0.98);
      border-left: 1px solid rgba(70, 70, 90, 0.5);
      display: flex;
      flex-direction: column;
      z-index: 999;
      transition: right 0.3s ease;
      backdrop-filter: blur(10px);
    }

    body:not(.dark-mode) .chat-sidebar {
      background-color: rgba(248, 249, 250, 0.98);
    }

    .chat-sidebar.open {
      right: 0;
    }

    .chat-header {
      padding: 15px 20px;
      border-bottom: 1px solid rgba(70, 70, 90, 0.5);
      display: flex;
      justify-content: between;
      align-items: center;
      background-color: rgba(20, 20, 30, 0.8);
    }

    body:not(.dark-mode) .chat-header {
      background-color: rgba(230, 230, 230, 0.8);
    }

    .chat-title {
      font-size: 1rem;
      font-weight: 600;
      color: #e0e0e0;
      flex: 1;
    }

    body:not(.dark-mode) .chat-title {
      color: #333;
    }

    .chat-close {
      background: none;
      border: none;
      color: #a0a0a0;
      cursor: pointer;
      font-size: 1.2rem;
      padding: 5px;
    }

    .chat-close:hover {
      color: #fff;
    }

    body:not(.dark-mode) .chat-close:hover {
      color: #333;
    }

    .chat-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .participants-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .participant-item {
      display: flex;
      align-items: center;
      padding: 0.5rem 1rem;
      border-bottom: 1px solid rgba(70, 70, 90, 0.3);
    }

    .participant-avatar {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      margin-right: 0.5rem;
      position: relative;
    }

    .participant-name {
      font-size: 0.9rem;
      flex: 1;
    }

    .participant-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-left: 0.5rem;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 15px 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .chat-input-container {
      display: flex;
      padding: 15px 20px;
      border-top: 1px solid rgba(70, 70, 90, 0.5);
      background-color: rgba(20, 20, 30, 0.8);
    }

    body:not(.dark-mode) .chat-input-container {
      background-color: rgba(230, 230, 230, 0.8);
    }

    .chat-input {
      flex: 1;
      border: 1px solid rgba(70, 70, 90, 0.5);
      border-radius: 20px;
      padding: 8px 15px;
      margin-right: 10px;
      background-color: rgba(40, 40, 50, 0.8);
      color: #e0e0e0;
      outline: none;
    }

    body:not(.dark-mode) .chat-input {
      background-color: rgba(255, 255, 255, 0.9);
      color: #333;
      border-color: #ccc;
    }

    .chat-send-btn {
      background-color: #007aff;
      border: none;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s ease;
    }

    .chat-send-btn:hover {
      background-color: #0056cc;
    }

    /* AI Chat Sidebar (Copilot style) */
    .ai-chat-sidebar {
      position: fixed;
      top: 0;
      right: -450px;
      width: 450px;
      height: 100vh;
      background-color: rgba(15, 15, 25, 0.98);
      border-left: 1px solid rgba(70, 70, 90, 0.5);
      display: flex;
      flex-direction: column;
      z-index: 998;
      transition: right 0.3s ease;
      backdrop-filter: blur(10px);
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
    }

    body:not(.dark-mode) .ai-chat-sidebar {
      background-color: rgba(248, 249, 250, 0.98);
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
    }

    .ai-chat-sidebar.open {
      right: 0;
    }

    .ai-chat-header {
      padding: 15px 20px;
      border-bottom: 1px solid rgba(70, 70, 90, 0.5);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(135deg, #1e1e2e, #2a2a3a);
    }

    body:not(.dark-mode) .ai-chat-header {
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
      border-bottom-color: rgba(200, 200, 200, 0.5);
    }

    .ai-chat-title-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .ai-chat-title-container i {
      color: #007aff;
      font-size: 1.1rem;
    }

    .ai-chat-title {
      font-size: 1rem;
      font-weight: 600;
      color: #e0e0e0;
      margin: 0;
    }

    body:not(.dark-mode) .ai-chat-title {
      color: #333;
    }

    .ai-chat-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .ai-model-selector {
      position: relative;
    }

    .ai-model-dropdown {
      background-color: rgba(40, 40, 50, 0.9);
      border: 1px solid rgba(70, 70, 90, 0.5);
      border-radius: 6px;
      color: #e0e0e0;
      padding: 6px 10px;
      font-size: 0.85rem;
      outline: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    body:not(.dark-mode) .ai-model-dropdown {
      background-color: rgba(255, 255, 255, 0.9);
      color: #333;
      border-color: #ccc;
    }

    .ai-model-dropdown:hover {
      background-color: rgba(50, 50, 60, 0.9);
    }

    body:not(.dark-mode) .ai-model-dropdown:hover {
      background-color: rgba(245, 245, 245, 0.9);
    }

    .ai-chat-close {
      background: none;
      border: none;
      color: #a0a0a0;
      cursor: pointer;
      font-size: 1.2rem;
      padding: 5px;
      transition: color 0.2s ease;
    }

    .ai-chat-close:hover {
      color: #fff;
    }

    body:not(.dark-mode) .ai-chat-close:hover {
      color: #333;
    }

    .ai-chat-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .ai-chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .ai-message {
      display: flex;
      gap: 12px;
      align-items: flex-start;
    }

    .ai-message-icon {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      font-size: 0.9rem;
    }

    .ai-message.ai-welcome .ai-message-icon,
    .ai-message.ai-assistant .ai-message-icon {
      background: linear-gradient(135deg, #007aff, #0056cc);
      color: white;
    }

    .ai-message.user .ai-message-icon {
      background: linear-gradient(135deg, #34c759, #28a745);
      color: white;
    }

    .ai-message-content {
      flex: 1;
      min-width: 0;
    }

    .ai-message-text {
      background-color: rgba(40, 40, 50, 0.6);
      border-radius: 12px;
      padding: 12px 16px;
      color: #e0e0e0;
      font-size: 0.9rem;
      line-height: 1.5;
      word-wrap: break-word;
    }

    body:not(.dark-mode) .ai-message-text {
      background-color: rgba(248, 249, 250, 0.8);
      color: #333;
    }

    .ai-message.user .ai-message-text {
      background-color: rgba(0, 122, 255, 0.1);
      border: 1px solid rgba(0, 122, 255, 0.2);
    }

    .ai-message-text ul {
      margin: 8px 0;
      padding-left: 20px;
    }

    .ai-message-text li {
      margin: 4px 0;
    }

    .ai-message-text code {
      background-color: rgba(70, 70, 90, 0.3);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.85rem;
    }

    body:not(.dark-mode) .ai-message-text code {
      background-color: rgba(220, 220, 220, 0.3);
    }

    .ai-message-text pre {
      background-color: rgba(20, 20, 30, 0.8);
      border-radius: 8px;
      padding: 12px;
      overflow-x: auto;
      margin: 8px 0;
    }

    body:not(.dark-mode) .ai-message-text pre {
      background-color: rgba(240, 240, 240, 0.8);
    }

    .ai-chat-actions {
      display: flex;
      gap: 8px;
      padding: 15px 20px;
      border-top: 1px solid rgba(70, 70, 90, 0.3);
      border-bottom: 1px solid rgba(70, 70, 90, 0.3);
      background-color: rgba(25, 25, 35, 0.6);
      flex-wrap: wrap;
    }

    body:not(.dark-mode) .ai-chat-actions {
      background-color: rgba(248, 249, 250, 0.6);
      border-color: rgba(200, 200, 200, 0.3);
    }

    .ai-action-btn {
      background-color: rgba(40, 40, 50, 0.8);
      border: 1px solid rgba(70, 70, 90, 0.5);
      border-radius: 6px;
      color: #e0e0e0;
      padding: 8px 12px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
      justify-content: center;
      min-width: 80px;
    }

    body:not(.dark-mode) .ai-action-btn {
      background-color: rgba(255, 255, 255, 0.8);
      color: #333;
      border-color: #ccc;
    }

    .ai-action-btn:hover {
      background-color: rgba(60, 60, 70, 0.8);
      border-color: rgba(100, 100, 120, 0.5);
      transform: translateY(-1px);
    }

    body:not(.dark-mode) .ai-action-btn:hover {
      background-color: rgba(240, 240, 240, 0.8);
    }

    .ai-action-btn i {
      font-size: 0.75rem;
    }

    .ai-chat-input-container {
      padding: 15px 20px;
      background-color: rgba(20, 20, 30, 0.8);
    }

    body:not(.dark-mode) .ai-chat-input-container {
      background-color: rgba(230, 230, 230, 0.8);
    }

    .ai-input-wrapper {
      display: flex;
      gap: 10px;
      align-items: flex-end;
    }

    .ai-chat-input {
      flex: 1;
      border: 1px solid rgba(70, 70, 90, 0.5);
      border-radius: 12px;
      padding: 12px 15px;
      background-color: rgba(40, 40, 50, 0.8);
      color: #e0e0e0;
      outline: none;
      resize: none;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 0.9rem;
      line-height: 1.4;
      max-height: 120px;
      transition: border-color 0.2s ease;
    }

    body:not(.dark-mode) .ai-chat-input {
      background-color: rgba(255, 255, 255, 0.9);
      color: #333;
      border-color: #ccc;
    }

    .ai-chat-input:focus {
      border-color: #007aff;
    }

    .ai-chat-input::placeholder {
      color: #888;
    }

    .ai-chat-send-btn {
      background-color: #007aff;
      border: none;
      border-radius: 8px;
      width: 40px;
      height: 40px;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .ai-chat-send-btn:hover {
      background-color: #0056cc;
      transform: translateY(-1px);
    }

    .ai-chat-send-btn:disabled {
      background-color: #555;
      cursor: not-allowed;
      transform: none;
    }

    .ai-input-hint {
      font-size: 0.75rem;
      color: #888;
      margin-top: 8px;
      text-align: center;
      font-style: italic;
    }

    /* Loading animation for AI responses */
    .ai-loading {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #888;
      font-style: italic;
    }

    .ai-loading-dots {
      display: flex;
      gap: 4px;
    }

    .ai-loading-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: #007aff;
      animation: ai-loading-bounce 1.4s infinite ease-in-out both;
    }

    .ai-loading-dot:nth-child(1) { animation-delay: -0.32s; }
    .ai-loading-dot:nth-child(2) { animation-delay: -0.16s; }

    @keyframes ai-loading-bounce {
      0%, 80%, 100% {
        transform: scale(0.8);
        opacity: 0.5;
      }
      40% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* Responsive design for AI chat */
    @media (max-width: 768px) {
      .ai-chat-sidebar {
        width: 100vw;
        right: -100vw;
      }
      
      .ai-chat-actions {
        flex-direction: column;
      }
      
      .ai-action-btn {
        min-width: 100%;
      }
    }



    body:not(.dark-mode) .monaco-editor .suggest-widget .suggest-status-bar {
      background-color: rgba(240, 240, 240, 0.9) !important;
    }

    /* AI suggestion indicator */
    .monaco-editor .suggest-widget .monaco-list .monaco-list-row[aria-label*="AI suggestion"] .suggest-icon {
      color: #007aff !important;
    }

    .monaco-editor .suggest-widget .monaco-list .monaco-list-row[aria-label*="AI suggestion"]::before {
      content: "ðŸ¤–";
      margin-right: 4px;
      font-size: 12px;
    }

    /* Autocomplete keyboard hint */
    .autocomplete-hint {
      position: fixed;
      bottom: 80px;
      right: 20px;
      background-color: rgba(0, 122, 255, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.8rem;
      z-index: 1000;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.3s ease;
      pointer-events: none;
    }

    .autocomplete-hint.show {
      opacity: 1;
      transform: translateY(0);
    }

    .autocomplete-hint kbd {
      background-color: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 0.7rem;
      font-family: monospace;
      margin: 0 2px;
    }

    /* Terminal Sidebar (Bottom slide-in) */
    .terminal-sidebar {
      position: fixed;
      bottom: -400px;
      left: 0;
      width: 100%;
      height: 400px;
      background-color: rgba(25, 25, 35, 0.98);
      border-top: 1px solid rgba(70, 70, 90, 0.5);
      display: flex;
      flex-direction: column;
      z-index: 999;
      transition: bottom 0.3s ease;
      backdrop-filter: blur(10px);
    }

    body:not(.dark-mode) .terminal-sidebar {
      background-color: rgba(248, 249, 250, 0.98);
    }

    .terminal-sidebar.open {
      bottom: 40px; /* Account for footer height */
    }

    .terminal-header {
      padding: 15px 20px;
      border-bottom: 1px solid rgba(70, 70, 90, 0.5);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: rgba(20, 20, 30, 0.8);
      min-height: 50px;
    }

    body:not(.dark-mode) .terminal-header {
      background-color: rgba(230, 230, 230, 0.8);
    }

    .terminal-title {
      font-size: 1rem;
      font-weight: 600;
      color: #e0e0e0;
      flex: 1;
      margin: 0;
    }

    body:not(.dark-mode) .terminal-title {
      color: #333;
    }

    .terminal-close {
      background: none;
      border: none;
      color: #a0a0a0;
      cursor: pointer;
      font-size: 1.2rem;
      padding: 5px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .terminal-close:hover {
      color: #fff;
      background-color: rgba(255, 255, 255, 0.1);
    }

    body:not(.dark-mode) .terminal-close:hover {
      color: #333;
      background-color: rgba(0, 0, 0, 0.1);
    }

    .terminal-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .terminal-output {
      flex: 1;
      padding: 15px 20px;
      overflow-y: auto;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.9rem;
      line-height: 1.4;
      color: #e0e0e0;
      background-color: rgba(15, 15, 25, 0.8);
    }

    body:not(.dark-mode) .terminal-output {
      background-color: rgba(255, 255, 255, 0.8);
      color: #333;
    }

    .terminal-line {
      margin-bottom: 4px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .terminal-input-container {
      display: flex;
      align-items: center;
      padding: 15px 20px;
      border-top: 1px solid rgba(70, 70, 90, 0.3);
      background-color: rgba(20, 20, 30, 0.8);
    }

    body:not(.dark-mode) .terminal-input-container {
      background-color: rgba(240, 240, 240, 0.8);
      border-top-color: rgba(200, 200, 200, 0.5);
    }

    .terminal-prompt {
      color: #00ff00;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-weight: bold;
      margin-right: 8px;
      user-select: none;
    }

    body:not(.dark-mode) .terminal-prompt {
      color: #007700;
    }

    .terminal-input-field {
      flex: 1;
      border: none;
      background: transparent;
      color: #e0e0e0;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.9rem;
      outline: none;
      padding: 5px 0;
    }

    body:not(.dark-mode) .terminal-input-field {
      color: #333;
    }

    .terminal-input-field::placeholder {
      color: #666;
    }

    body:not(.dark-mode) .terminal-input-field::placeholder {
      color: #999;
    }

    /* Footer Terminal Panel */
    .footer-terminal {
      position: fixed;
      bottom: 60px; /* Above the footer */
      left: 0;
      right: 0;
      height: 250px;
      background-color: rgba(25, 25, 35, 0.98);
      border-top: 1px solid rgba(70, 70, 90, 0.5);
      transform: translateY(100%);
      transition: transform 0.3s ease;
      z-index: 800;
      backdrop-filter: blur(10px);
      display: none;
    }

    body:not(.dark-mode) .footer-terminal {
      background-color: rgba(255, 255, 255, 0.98);
      border-top-color: rgba(200, 200, 200, 0.5);
    }

    .footer-terminal.open {
      transform: translateY(0);
      display: block;
    }

    .footer-terminal .terminal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      background-color: rgba(20, 20, 30, 0.9);
      border-bottom: 1px solid rgba(70, 70, 90, 0.3);
    }

    body:not(.dark-mode) .footer-terminal .terminal-header {
      background-color: rgba(240, 240, 240, 0.9);
      border-bottom-color: rgba(200, 200, 200, 0.5);
    }

    .footer-terminal .terminal-title {
      color: #e0e0e0;
      font-size: 0.9rem;
      font-weight: 600;
      margin: 0;
    }

    body:not(.dark-mode) .footer-terminal .terminal-title {
      color: #333;
    }

    .footer-terminal .terminal-close {
      background: none;
      border: none;
      color: #888;
      cursor: pointer;
      padding: 4px;
      border-radius: 3px;
      transition: all 0.2s ease;
    }

    .footer-terminal .terminal-close:hover {
      background-color: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    body:not(.dark-mode) .footer-terminal .terminal-close:hover {
      background-color: rgba(0, 0, 0, 0.1);
      color: #000;
    }

    .footer-terminal .terminal-content {
      height: calc(100% - 45px);
      overflow: hidden;
    }

    /* Modal Popups */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1001;
      backdrop-filter: blur(3px);
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal-container {
      background-color: rgba(25, 25, 35, 0.98);
      border-radius: 8px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(70, 70, 90, 0.5);
    }

    body:not(.dark-mode) .modal-container {
      background-color: rgba(255, 255, 255, 0.98);
      border-color: #ddd;
    }

    .modal-header {
      padding: 20px;
      border-bottom: 1px solid rgba(70, 70, 90, 0.5);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: rgba(20, 20, 30, 0.8);
    }

    body:not(.dark-mode) .modal-header {
      background-color: rgba(240, 240, 240, 0.8);
      border-color: #ddd;
    }

    .modal-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #e0e0e0;
      margin: 0;
    }

    body:not(.dark-mode) .modal-title {
      color: #333;
    }

    .modal-close {
      background: none;
      border: none;
      color: #a0a0a0;
      cursor: pointer;
      font-size: 1.3rem;
      padding: 5px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .modal-close:hover {
      color: #fff;
      background-color: rgba(255, 255, 255, 0.1);
    }

    body:not(.dark-mode) .modal-close:hover {
      color: #333;
      background-color: rgba(0, 0, 0, 0.1);
    }

    .modal-content {
      padding: 20px;
      overflow-y: auto;
      max-height: calc(80vh - 140px);
    }

    /* Participants Modal */
    .participants-count-display {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 15px;
      margin-bottom: 15px;
      background-color: rgba(40, 40, 50, 0.3);
      border-radius: 8px;
      border: 1px solid rgba(70, 70, 90, 0.3);
      color: #e0e0e0;
      font-weight: 500;
    }

    body:not(.dark-mode) .participants-count-display {
      background-color: rgba(240, 240, 240, 0.8);
      border-color: #e0e0e0;
      color: #333;
    }

    .participants-count-display i {
      color: var(--ios-primary);
    }

    .participants-grid {
      display: grid;
      gap: 15px;
    }

    .participant-card {
      display: flex;
      align-items: center;
      padding: 15px;
      background-color: rgba(40, 40, 50, 0.5);
      border-radius: 8px;
      border: 1px solid rgba(70, 70, 90, 0.3);
    }

    body:not(.dark-mode) .participant-card {
      background-color: rgba(250, 250, 250, 0.8);
      border-color: #e0e0e0;
    }

    .participant-card-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin-right: 15px;
    }

    .participant-info {
      flex: 1;
    }

    .participant-card-name {
      font-weight: 600;
      color: #e0e0e0;
      margin-bottom: 4px;
    }

    body:not(.dark-mode) .participant-card-name {
      color: #333;
    }

    .participant-status {
      font-size: 0.85rem;
      color: #a0a0a0;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #4caf50;
    }

    /* Settings Modal */
    .settings-section {
      margin-bottom: 25px;
    }

    .settings-section-title {
      font-size: 1rem;
      font-weight: 600;
      color: #e0e0e0;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    body:not(.dark-mode) .settings-section-title {
      color: #333;
    }

    .setting-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid rgba(70, 70, 90, 0.3);
    }

    body:not(.dark-mode) .setting-item {
      border-color: #e0e0e0;
    }

    .setting-item:last-child {
      border-bottom: none;
    }

    .setting-label {
      flex: 1;
    }

    .setting-name {
      font-weight: 500;
      color: #e0e0e0;
      margin-bottom: 4px;
    }

    body:not(.dark-mode) .setting-name {
      color: #333;
    }

    .setting-description {
      font-size: 0.85rem;
      color: #a0a0a0;
    }

    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(70, 70, 90, 0.5);
      transition: .4s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: #007aff;
    }

    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }

    /* Voice Chat Options Modal Styles */
    .voice-participants-section {
      margin-bottom: 30px;
    }

    .voice-section-title {
      font-size: 1rem;
      font-weight: 600;
      color: #e0e0e0;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    body:not(.dark-mode) .voice-section-title {
      color: #333;
    }

    .voice-participants-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 200px;
      overflow-y: auto;
    }

    .voice-participant-card {
      display: flex;
      align-items: center;
      padding: 12px;
      background-color: rgba(40, 40, 50, 0.5);
      border-radius: 8px;
      border: 1px solid rgba(70, 70, 90, 0.3);
    }

    body:not(.dark-mode) .voice-participant-card {
      background-color: rgba(250, 250, 250, 0.8);
      border-color: #e0e0e0;
    }

    .voice-participant-avatar {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      margin-right: 12px;
    }

    .voice-participant-info {
      flex: 1;
    }

    .voice-participant-name {
      font-weight: 500;
      color: #e0e0e0;
      margin-bottom: 2px;
    }

    body:not(.dark-mode) .voice-participant-name {
      color: #333;
    }

    .voice-participant-status {
      font-size: 0.8rem;
      color: #a0a0a0;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .voice-status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #28a745;
    }

    .voice-status-indicator.muted {
      background-color: #dc3545;
    }

    .voice-status-indicator.deafened {
      background-color: #ffc107;
    }

    .no-voice-participants {
      text-align: center;
      padding: 30px 20px;
      color: #a0a0a0;
    }

    .no-voice-participants i {
      font-size: 2rem;
      margin-bottom: 10px;
      opacity: 0.5;
    }

    .no-voice-participants p {
      margin: 0;
      font-size: 0.9rem;
    }

    .voice-controls-section {
      border-top: 1px solid rgba(70, 70, 90, 0.3);
      padding-top: 20px;
    }

    body:not(.dark-mode) .voice-controls-section {
      border-color: #e0e0e0;
    }

    .voice-control-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px 0;
      border-bottom: 1px solid rgba(70, 70, 90, 0.2);
    }

    body:not(.dark-mode) .voice-control-item {
      border-color: #f0f0f0;
    }

    .voice-control-item:last-child {
      border-bottom: none;
    }

    .voice-control-info {
      flex: 1;
    }

    .voice-control-name {
      font-weight: 500;
      color: #e0e0e0;
      margin-bottom: 4px;
    }

    body:not(.dark-mode) .voice-control-name {
      color: #333;
    }

    .voice-control-description {
      font-size: 0.85rem;
      color: #a0a0a0;
    }

    .voice-control-btn {
      padding: 8px 16px;
      border: 1px solid rgba(70, 70, 90, 0.5);
      border-radius: 6px;
      background-color: rgba(40, 40, 50, 0.5);
      color: #e0e0e0;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9rem;
    }

    body:not(.dark-mode) .voice-control-btn {
      background-color: rgba(250, 250, 250, 0.8);
      border-color: #ddd;
      color: #333;
    }

    .voice-control-btn:hover {
      background-color: rgba(60, 60, 80, 0.7);
      border-color: #007aff;
    }

    body:not(.dark-mode) .voice-control-btn:hover {
      background-color: rgba(240, 240, 240, 0.9);
      border-color: #007aff;
    }

    .voice-control-btn.active {
      background-color: #007aff;
      border-color: #007aff;
      color: white;
    }

    .voice-control-btn.danger {
      border-color: #dc3545;
      color: #dc3545;
    }

    .voice-control-btn.danger:hover {
      background-color: #dc3545;
      color: white;
    }

    /* Theme Selector */
    .theme-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .theme-option {
      padding: 12px;
      border: 2px solid rgba(70, 70, 90, 0.3);
      border-radius: 6px;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s ease;
      background-color: rgba(40, 40, 50, 0.3);
    }

    body:not(.dark-mode) .theme-option {
      background-color: rgba(250, 250, 250, 0.5);
      border-color: #e0e0e0;
    }

    .theme-option:hover {
      border-color: #007aff;
    }

    .theme-option.active {
      border-color: #007aff;
      background-color: rgba(0, 122, 255, 0.1);
    }

    .theme-preview {
      width: 100%;
      height: 30px;
      border-radius: 4px;
      margin-bottom: 8px;
      display: flex;
    }

    .theme-preview.vs-dark {
      background: linear-gradient(90deg, #1e1e1e 0%, #252526 100%);
    }

    .theme-preview.vs-light {
      background: linear-gradient(90deg, #ffffff 0%, #f3f3f3 100%);
    }

    .theme-preview.github-dark {
      background: linear-gradient(90deg, #0d1117 0%, #21262d 100%);
    }

    .theme-preview.github-light {
      background: linear-gradient(90deg, #ffffff 0%, #f6f8fa 100%);
    }

    .theme-preview.monokai {
      background: linear-gradient(90deg, #272822 0%, #3e3d32 100%);
    }

    .theme-name {
      font-size: 0.85rem;
      color: #e0e0e0;
      font-weight: 500;
    }

    body:not(.dark-mode) .theme-name {
      color: #333;
    }

    /* Edit Permission Button Styles */
    #request-edit-btn {
      background-color: #ffc107 !important;
      border-color: #ffc107 !important;
      color: #000 !important;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    #request-edit-btn:hover {
      background-color: #ffca2c !important;
      border-color: #ffca2c !important;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(255, 193, 7, 0.3);
    }

    #done-editing-btn {
      background-color: #28a745 !important;
      border-color: #28a745 !important;
      color: #fff !important;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    #done-editing-btn:hover {
      background-color: #218838 !important;
      border-color: #218838 !important;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
    }

    .message {
      margin-bottom: 0.5rem;
      max-width: 80%;
    }

    .message.outgoing {
      align-self: flex-end;
      background-color: #0a84ff;
      color: white;
      border-radius: 18px 18px 0 18px;
      box-shadow: 0 2px 5px rgba(10, 132, 255, 0.3);
      padding: 0.5rem 0.75rem;
    }

    .message.incoming {
      align-self: flex-start;
      background-color: rgba(60, 60, 80, 0.5);
      border-radius: 18px 18px 18px 0;
      color: #e0e0e0;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      padding: 0.5rem 0.75rem;
    }

    .message-sender {
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .message-time {
      font-size: 0.7rem;
      opacity: 0.7;
      margin-top: 0.25rem;
      text-align: right;
    }

    .remote-cursor {
      position: absolute;
      z-index: 1000;
      pointer-events: none;
      font-family: 'Inter', sans-serif;
    }

    .cursor-caret {
      width: 2px;
      height: 18px;
      position: absolute;
      animation: blink 1s infinite;
      border-radius: 1px;
      box-shadow: 0 0 2px rgba(0,0,0,0.3);
    }

    .cursor-label {
      position: absolute;
      padding: 3px 8px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 500;
      white-space: nowrap;
      color: white;
      transform: translateY(-100%);
      opacity: 0.95;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      margin-top: -2px;
      margin-left: -4px;
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    /* Dark mode adjustments */
    body.dark-mode .top-navbar {
      background-color: var(--ios-dark-card-bg);
      border-bottom-color: var(--ios-gray-1);
    }

    body.dark-mode .sidebar {
      background-color: #1e1e1e;
      border-right-color: var(--ios-gray-1);
    }

    body.dark-mode .files-list li {
      border-bottom-color: var(--ios-gray-1);
    }

    body.dark-mode .files-list li:hover {
      background-color: #2d2d2d;
    }

    body.dark-mode .chat-input {
      background-color: #2d2d2d;
      color: var(--ios-dark-text);
      border-color: var(--ios-gray-1);
    }

    body.dark-mode .message.incoming {
      background-color: #2d2d2d;
      color: var(--ios-dark-text);
    }

    /* Responsive adjustments */
    @media (max-width: 992px) {
      .sidebar {
        width: 200px;
      }

      .chat-sidebar {
        width: 100%;
        right: -100%;
      }

      .modal-container {
        width: 95%;
        margin: 20px;
      }

      .footer-section {
        padding: 0 10px;
      }

      .footer-left {
        font-size: 0.8rem;
      }

      .footer-btn {
        padding: 6px 8px;
        font-size: 0.8rem;
      }

      .theme-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      /* Hide edit buttons on smaller screens to save space */
      #request-edit-btn,
      #done-editing-btn {
        display: none !important;
      }
    }

    @media (max-width: 768px) {
      .main-content {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        height: 120px;
        border-right: none;
        border-bottom: 1px solid rgba(70, 70, 90, 0.5);
        flex-direction: row;
        overflow-x: auto;
      }

      .files-list {
        display: flex;
        flex-direction: row;
        white-space: nowrap;
      }

      .files-list li {
        border-right: 1px solid rgba(70, 70, 90, 0.3);
        border-bottom: none;
        min-width: 120px;
      }

      .bottom-panel {
        height: 200px;
      }

      .chat-sidebar {
        width: 100%;
        right: -100%;
      }

      .footer-section {
        flex-direction: column;
        height: 60px;
        padding: 5px 10px;
      }

      .footer-left, .footer-right {
        justify-content: center;
      }

      .footer-left {
        margin-bottom: 5px;
      }

      .footer-btn {
        padding: 4px 6px;
        font-size: 0.75rem;
        gap: 4px;
      }

      .modal-container {
        width: 100%;
        height: 100%;
        border-radius: 0;
        margin: 0;
      }

      .theme-grid {
        grid-template-columns: 1fr;
      }

      .settings-section {
        margin-bottom: 20px;
      }

      .terminal-sidebar {
        height: 350px;
      }

      .terminal-sidebar.open {
        bottom: 40px; /* Account for mobile footer */
      }

      .terminal-output {
        font-size: 0.85rem;
        padding: 10px 15px;
      }

      .terminal-input-container {
        padding: 10px 15px;
      }

      .terminal-header {
        padding: 10px 15px;
        min-height: 45px;
      }
    }

    /* Theme toggle button */
    .theme-toggle {
      background: none;
      border: none;
      color: var(--ios-gray-1);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0.5rem;
      margin-left: 0.5rem;
    }

    /* Collapse/expand button for chat */
    .collapse-btn {
      background: none;
      border: none;
      color: var(--ios-gray-1);
      cursor: pointer;
      padding: 0.5rem;
    }

    /* Professional notification side popup */
    .notification-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      width: 350px;
      max-width: 90vw;
      pointer-events: none;
    }

    .notification-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      transform: translateX(100%);
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      pointer-events: auto;
      position: relative;
      overflow: hidden;
    }

    body.dark-mode .notification-item {
      background: rgba(30, 30, 35, 0.95);
      border-color: rgba(70, 70, 90, 0.3);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .notification-item.show {
      transform: translateX(0);
    }

    .notification-item.fade-out {
      transform: translateX(100%);
      opacity: 0;
    }

    .notification-icon {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      font-size: 12px;
      font-weight: 600;
      color: white;
    }

    .notification-item.success .notification-icon {
      background: linear-gradient(135deg, #10b981, #059669);
    }

    .notification-item.error .notification-icon {
      background: linear-gradient(135deg, #ef4444, #dc2626);
    }

    .notification-item.info .notification-icon {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
    }

    .notification-item.warning .notification-icon {
      background: linear-gradient(135deg, #f59e0b, #d97706);
    }

    .notification-content {
      flex: 1;
      min-width: 0;
    }

    .notification-title {
      font-weight: 600;
      font-size: 14px;
      color: #1f2937;
      margin-bottom: 4px;
      line-height: 1.3;
    }

    body.dark-mode .notification-title {
      color: #f9fafb;
    }

    .notification-message {
      font-size: 13px;
      color: #6b7280;
      line-height: 1.4;
      word-wrap: break-word;
    }

    body.dark-mode .notification-message {
      color: #d1d5db;
    }

    .notification-close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 20px;
      height: 20px;
      border: none;
      background: none;
      color: #9ca3af;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      font-size: 12px;
      transition: all 0.2s ease;
      opacity: 0;
      pointer-events: none;
    }

    .notification-item:hover .notification-close {
      opacity: 1;
      pointer-events: auto;
    }

    .notification-close:hover {
      background: rgba(156, 163, 175, 0.2);
      color: #374151;
    }

    body.dark-mode .notification-close:hover {
      background: rgba(156, 163, 175, 0.1);
      color: #f3f4f6;
    }

    .notification-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background: linear-gradient(90deg, #3b82f6, #1d4ed8);
      border-radius: 0 0 12px 12px;
      transform-origin: left;
      animation: progressBar 4s linear forwards;
    }

    .notification-item.success .notification-progress {
      background: linear-gradient(90deg, #10b981, #059669);
    }

    .notification-item.error .notification-progress {
      background: linear-gradient(90deg, #ef4444, #dc2626);
    }

    .notification-item.warning .notification-progress {
      background: linear-gradient(90deg, #f59e0b, #d97706);
    }

    @keyframes progressBar {
      from { transform: scaleX(1); }
      to { transform: scaleX(0); }
    }

    /* Mobile responsive */
    @media (max-width: 480px) {
      .notification-container {
        top: 10px;
        right: 10px;
        left: 10px;
        width: auto;
      }
      
      .notification-item {
        margin-bottom: 8px;
        padding: 12px 16px;
      }
    }

    /* Accessibility and keyboard navigation */
    .footer-btn:focus,
    .modal-close:focus,
    .chat-close:focus {
      outline: 2px solid #007aff;
      outline-offset: 2px;
    }

    .toggle-switch:focus-within {
      outline: 2px solid #007aff;
      outline-offset: 2px;
      border-radius: 24px;
    }

    .theme-option:focus {
      outline: 2px solid #007aff;
      outline-offset: 2px;
    }

    /* Smooth animations */
    .chat-sidebar,
    .modal-overlay,
    .footer-btn,
    .theme-option,
    .setting-item {
      transition: all 0.2s ease;
    }

    /* Chat sidebar overlay for mobile */
    @media (max-width: 768px) {
      .chat-sidebar.open::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: -1;
      }
    }
  </style>
</head>
<body class="dark-mode">
  <!-- Spline Background -->
  <div class="spline-container">
    <spline-viewer url="https://prod.spline.design/HAPDwhAWHdkj3Od2/scene.splinecode"></spline-viewer>
  </div>

  <!-- Fallback Gradient Background -->
  <div class="gradient-bg"></div>

  <div class="room-container">
    <!-- Top Navbar -->
    <div class="top-navbar d-flex justify-content-between align-items-center shadow-sm mb-1">
      <div class="d-flex align-items-center">
        <h4 class="room-name mb-0" contenteditable="<%= roomData.createdBy === (req.user._id || req.user.id || req.user.googleId) ? 'true' : 'false' %>">
          <%= roomData.name %>
        </h4>
        <span class="badge bg-secondary ms-2 text-xs">ID: <%= roomData.id %></span>
        <div class="user-avatars ms-3">
          <div class="avatar">
            <img src="<%= req.user.picture || 'https://ui-avatars.com/api/?name=' + req.user.username %>" alt="Your avatar">
            <div class="online-indicator"></div>
          </div>
          <div id="remote-avatars"></div>
        </div>
        <span class="ms-2 text-muted">
          <i class="fas fa-users"></i> <span id="online-count">1</span> online
        </span>
        <span class="ms-3 text-info" id="current-editor-indicator" style="display: none;">
          <i class="fas fa-edit"></i> <span id="current-editor-name">You</span> is editing
        </span>
      </div>
      <div class="d-flex align-items-center">
        <div class="dropdown me-3">
          <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" id="languageDropdown" data-bs-toggle="dropdown">
            <i class="fas fa-code"></i> <span id="selected-language"><%= roomData.language %></span>
          </button>
          <ul class="dropdown-menu" aria-labelledby="languageDropdown">
            <li><a class="dropdown-item language-option" data-language="javascript" href="#">JavaScript</a></li>
            <li><a class="dropdown-item language-option" data-language="typescript" href="#">TypeScript</a></li>
            <li><a class="dropdown-item language-option" data-language="python" href="#">Python</a></li>
            <li><a class="dropdown-item language-option" data-language="java" href="#">Java</a></li>
            <li><a class="dropdown-item language-option" data-language="csharp" href="#">C#</a></li>
            <li><a class="dropdown-item language-option" data-language="cpp" href="#">C++</a></li>
            <li><a class="dropdown-item language-option" data-language="php" href="#">PHP</a></li>
            <li><a class="dropdown-item language-option" data-language="ruby" href="#">Ruby</a></li>
            <li><a class="dropdown-item language-option" data-language="go" href="#">Go</a></li>
            <li><a class="dropdown-item language-option" data-language="rust" href="#">Rust</a></li>
            <li><a class="dropdown-item language-option" data-language="html" href="#">HTML</a></li>
            <li><a class="dropdown-item language-option" data-language="css" href="#">CSS</a></li>
            <li><a class="dropdown-item language-option" data-language="sql" href="#">SQL</a></li>
          </ul>
        </div>
        <button class="btn btn-sm btn-dark me-2" id="add-file">
          <i class="fas fa-plus"></i> New File
        </button>
        <button class="btn btn-sm btn-dark me-2" id="copy-link">
          <i class="fas fa-link"></i> Copy Link
        </button>
        <button class="btn btn-sm btn-primary me-2" id="run-code">
          <i class="fas fa-play"></i> Run
        </button>
        <!-- Edit Permission Controls -->
        <button class="btn btn-sm btn-warning me-2" id="request-edit-btn" style="display: none;">
          <i class="fas fa-hand-paper"></i> Request Edit Access
        </button>
        <button class="btn btn-sm btn-success me-2" id="done-editing-btn" style="display: none;">
          <i class="fas fa-check"></i> Done Editing
        </button>
        <button class="btn btn-sm btn-outline-danger" id="leave-room">Leave</button>
        <button class="theme-toggle" id="theme-toggle">
          <i class="fas fa-moon"></i>
        </button>
        <button class="btn btn-sm btn-dark ms-2" id="toggle-performance" title="Toggle performance mode">
          <i class="fas fa-bolt"></i>
        </button>
      </div>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
      <!-- Sidebar for Files -->
      <div class="sidebar">
        <div class="d-flex justify-content-between align-items-center p-3 border-bottom">
          <h6 class="sidebar-title mb-0">Files</h6>
          <div class="file-actions">
            <button class="btn btn-sm btn-outline-primary me-1" id="save-file" title="Save current file">
              <i class="fas fa-save"></i>
            </button>
            <button class="btn btn-sm btn-outline-danger" id="close-file" title="Close current file">
              <i class="fas fa-times"></i>
            </button>
          </div>
        </div>
        <ul class="files-list" id="files-list">
          <% roomData.files.forEach((file, index) => { %>
            <li class="<%= index === 0 ? 'active' : '' %>" data-file-index="<%= index %>">
              <% if (file.type === 'js') { %>
                <i class="file-icon fab fa-js-square"></i>
              <% } else if (file.type === 'html') { %>
                <i class="file-icon fab fa-html5"></i>
              <% } else if (file.type === 'css') { %>
                <i class="file-icon fab fa-css3-alt"></i>
              <% } else { %>
                <i class="file-icon far fa-file-code"></i>
              <% } %>
              <%= file.name %>
            </li>
          <% }); %>
        </ul>
      </div>

      <!-- Monaco Editor -->
      <div class="monaco-editor-container">
        <div id="monaco-editor" style="width: 100%; height: 100%; min-height: 300px; display: none;">
          <!-- Monaco editor will be loaded here -->
        </div>
        <!-- CodeMirror editor (fallback) -->
      </div>
    </div>

    <!-- Footer Section -->
    <div class="footer-section">
      <div class="footer-left">
        <span><i class="fas fa-users"></i> <span id="online-count">1</span> online</span>
        <span><i class="fas fa-code"></i> <%= roomData.language %></span>
      </div>
      <div class="footer-right">
        <!-- Voice Chat Controls -->
        <% if (req.user && req.user.subscription && req.user.subscription.isPro) { %>
          <button class="footer-btn" id="join-voice-btn" title="Join Voice Chat" style="position: relative;">
            <i class="fas fa-microphone"></i>
            Join Voice
            <span id="voice-participants-indicator">0</span>
          </button>
        <% } else { %>
          <button class="footer-btn" id="join-voice-btn" title="Voice Chat (1 Hour Free Trial)" style="position: relative; background: linear-gradient(135deg, #4CAF50, #45a049); color: white;">
            <i class="fas fa-microphone"></i>
            Try Voice Chat
            <span style="position: absolute; top: -8px; right: -8px; background: #ff6b35; color: white; border-radius: 50%; width: 24px; height: 20px; font-size: 9px; display: flex; align-items: center; justify-content: center; font-weight: bold;">1HR</span>
          </button>
        <% } %>
        <button class="btn btn-sm btn-outline-danger" id="mute-btn" style="display: none;" title="Toggle Microphone">
          <i class="fas fa-microphone-slash"></i>
          Mute
        </button>
        <button class="btn btn-sm btn-outline-danger" id="deafen-btn" style="display: none;" title="Toggle Audio (Deafen)">
          <i class="fas fa-volume-mute"></i>
          Deafen
        </button>
        <button class="footer-btn" id="leave-voice-btn" style="display: none;" title="Leave Voice Chat">
          <i class="fas fa-door-open"></i>
          Leave Call
        </button>
        <button class="footer-btn" id="voice-chat-options-btn" style="display: none;" title="Voice Chat Options">
          <i class="fas fa-cog"></i>
          Voice Chat Options
        </button>
        
        <!-- Existing buttons -->
        <button class="footer-btn" id="footer-chat-btn">
          <i class="fas fa-comments"></i>
          Chat
        </button>
        <button class="footer-btn" id="footer-ai-chat-btn">
          <i class="fas fa-robot"></i>
          AI Chat
        </button>
        <button class="footer-btn" id="footer-participants-btn">
          <i class="fas fa-users"></i>
          Participants
        </button>
        <button class="footer-btn" id="footer-settings-btn">
          <i class="fas fa-cog"></i>
          Settings
        </button>
        <button class="footer-btn" id="footer-terminal-btn">
          <i class="fas fa-terminal"></i>
          Terminal
        </button>
      </div>
    </div>
  </div>

  <!-- Footer Terminal Panel -->
  <div class="footer-terminal" id="footer-terminal">
    <div class="terminal-header">
      <h6 class="terminal-title">Output Terminal</h6>
      <button class="terminal-close" id="footer-terminal-close">
        <i class="fas fa-minus"></i>
      </button>
    </div>
    <div class="terminal-content">
      <div class="terminal-output" id="terminal" style="height: 200px; overflow-y: auto; background: #1e1e1e; color: #ffffff; padding: 10px; font-family: 'Courier New', monospace; border-radius: 4px;">
        <div class="terminal-line" style="color: #4a9eff;">CodeCollab Output Terminal v1.0</div>
        <div class="terminal-line" style="color: #6b7280;">Code execution results will appear here...</div>
        <div class="terminal-input">
          <span class="terminal-input-prompt">$</span>
          <input type="text" class="terminal-input-field" id="terminal-input" placeholder="Enter bash command..." spellcheck="false">
        </div>
      </div>
    </div>
  </div>

  <!-- Chat Sidebar (VS Code style) -->
  <div class="chat-sidebar" id="chat-sidebar">
    <div class="chat-header">
      <h6 class="chat-title">Chat</h6>
      <button class="chat-close" id="chat-close-btn">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="chat-content">
      <div class="chat-messages" id="chat-messages">
        <!-- Messages will be added here dynamically -->
      </div>
      <div class="chat-input-container">
        <input type="text" class="chat-input" id="chat-input" placeholder="Type a message...">
        <button class="chat-send-btn" id="send-message">
          <i class="fas fa-paper-plane"></i>
        </button>
      </div>
    </div>
  </div>

  <!-- AI Chat Sidebar (Copilot style) -->
  <div class="ai-chat-sidebar" id="ai-chat-sidebar">
    <div class="ai-chat-header">
      <div class="ai-chat-title-container">
        <i class="fas fa-robot"></i>
        <h6 class="ai-chat-title">AI Assistant</h6>
        <small class="ai-usage-counter" id="ai-usage-counter" style="margin-left: 8px; opacity: 0.7; font-size: 11px;">Loading...</small>
      </div>
      <div class="ai-chat-controls">
        <div class="ai-model-selector">
          <select id="ai-model-select" class="ai-model-dropdown">
            <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash</option>
            <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
            <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
            <option value="gemini-1.0-pro">Gemini 1.0 Pro</option>
          </select>
        </div>
        <button class="ai-chat-close" id="ai-chat-close-btn">
          <i class="fas fa-times"></i>
        </button>
      </div>
    </div>
    <div class="ai-chat-content">
      <div class="ai-chat-messages" id="ai-chat-messages">
        <div class="ai-message ai-welcome">
          <div class="ai-message-icon">
            <i class="fas fa-robot"></i>
          </div>
          <div class="ai-message-content">
            <div class="ai-message-text">
              ðŸ‘‹ Hi! I'm your AI coding assistant. I can help you with:
              <ul>
                <li>ðŸ› Debug your code</li>
                <li>ðŸ’¡ Explain code concepts</li>
                <li>âš¡ Optimize performance</li>
                <li>ðŸ“ Write code snippets</li>
                <li>ðŸ” Code reviews</li>
              </ul>
              Ask me anything about your code!
            </div>
          </div>
        </div>
      </div>
      <div class="ai-chat-actions">
        <button class="ai-action-btn" id="ai-analyze-code" title="Analyze current code">
          <i class="fas fa-search"></i>
          Analyze Code
        </button>
        <button class="ai-action-btn" id="ai-debug-code" title="Debug current code">
          <i class="fas fa-bug"></i>
          Debug
        </button>
        <button class="ai-action-btn" id="ai-optimize-code" title="Optimize current code">
          <i class="fas fa-bolt"></i>
          Optimize
        </button>
        <button class="ai-action-btn" id="ai-explain-code" title="Explain current code">
          <i class="fas fa-question-circle"></i>
          Explain
        </button>
      </div>
      <div class="ai-chat-input-container">
        <div class="ai-input-wrapper">
          <textarea class="ai-chat-input" id="ai-chat-input" placeholder="Ask me about your code..." rows="1"></textarea>
          <button class="ai-chat-send-btn" id="ai-send-message">
            <i class="fas fa-paper-plane"></i>
          </button>
        </div>
        <div class="ai-input-hint">
          ðŸ’¡ Tip: Select code in the editor and ask specific questions
        </div>
      </div>
    </div>
  </div>

  <!-- Professional Notification Container -->
  <div class="notification-container" id="notification-container">
    <!-- Notifications will be dynamically added here -->
  </div>

  <!-- Terminal Sidebar (Bottom slide-in) -->
  <div class="terminal-sidebar" id="terminal-sidebar">
    <div class="terminal-header">
      <h6 class="terminal-title">Terminal</h6>
      <button class="terminal-close" id="terminal-close-btn">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="terminal-content">
      <div class="terminal-output" id="terminal-output">
        <div class="terminal-line">CodeCollab Terminal v1.0</div>
        <div class="terminal-line">Type your bash commands below:</div>
      </div>
      <div class="terminal-input-container">
        <span class="terminal-prompt">$ </span>
        <input type="text" class="terminal-input-field" id="terminal-input-sidebar" placeholder="Enter command..." spellcheck="false" autocomplete="off">
      </div>
    </div>
  </div>

  <!-- Participants Modal -->
  <div class="modal-overlay" id="participants-modal">
    <div class="modal-container">
      <div class="modal-header">
        <h3 class="modal-title">Participants</h3>
        <button class="modal-close" id="participants-close-btn">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-content">
        <div class="participants-count-display">
          <i class="fas fa-users"></i>
          <span id="participants-count">1</span> participant(s) online
        </div>
        <div class="participants-grid" id="participants-grid">
          <!-- Current user - added for consistency -->
          <div class="participant-card" id="participant-card-<%= req.user._id || req.user.id || req.user.googleId %>">
            <img src="<%= req.user.picture || 'https://ui-avatars.com/api/?name=' + req.user.username %>" alt="Your avatar" class="participant-card-avatar">
            <div class="participant-info">
              <div class="participant-card-name"><%= req.user.username || req.user.displayName || req.user.email.split("@")[0] %> (You)</div>
              <div class="participant-status">
                <div class="status-indicator"></div>
                Online
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settings-modal">
    <div class="modal-container">
      <div class="modal-header">
        <h3 class="modal-title">Settings</h3>
        <button class="modal-close" id="settings-close-btn">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-content">
        <!-- Editor Settings -->
        <div class="settings-section">
          <h4 class="settings-section-title">
            <i class="fas fa-edit"></i>
            Editor
          </h4>
          <div class="setting-item">
            <div class="setting-label">
              <div class="setting-name">Show Remote Cursors</div>
              <div class="setting-description">Display cursors of other participants</div>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="setting-show-cursors" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <div class="setting-name">Auto Save</div>
              <div class="setting-description">Automatically save changes</div>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="setting-auto-save" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <div class="setting-name">Line Numbers</div>
              <div class="setting-description">Show line numbers in editor</div>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="setting-line-numbers" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <div class="setting-name">Minimap</div>
              <div class="setting-description">Show code minimap</div>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="setting-minimap" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>

        <!-- Theme Settings -->
        <div class="settings-section">
          <h4 class="settings-section-title">
            <i class="fas fa-palette"></i>
            Theme
          </h4>
          <div class="theme-grid">
            <div class="theme-option active" data-theme="vs-dark">
              <div class="theme-preview vs-dark"></div>
              <div class="theme-name">VS Dark</div>
            </div>
            <div class="theme-option" data-theme="vs-light">
              <div class="theme-preview vs-light"></div>
              <div class="theme-name">VS Light</div>
            </div>
            <div class="theme-option" data-theme="github-dark">
              <div class="theme-preview github-dark"></div>
              <div class="theme-name">GitHub Dark</div>
            </div>
            <div class="theme-option" data-theme="github-light">
              <div class="theme-preview github-light"></div>
              <div class="theme-name">GitHub Light</div>
            </div>
            <div class="theme-option" data-theme="monokai">
              <div class="theme-preview monokai"></div>
              <div class="theme-name">Monokai</div>
            </div>
          </div>
        </div>

        <!-- Collaboration Settings -->
        <div class="settings-section">
          <h4 class="settings-section-title">
            <i class="fas fa-users"></i>
            Collaboration
          </h4>
          <div class="setting-item">
            <div class="setting-label">
              <div class="setting-name">Real-time Sync</div>
              <div class="setting-description">Sync code changes in real-time</div>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="setting-realtime-sync" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <div class="setting-name">Chat Notifications</div>
              <div class="setting-description">Show notifications for new messages</div>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="setting-chat-notifications" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <div class="setting-name">Join/Leave Alerts</div>
              <div class="setting-description">Show when users join or leave</div>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="setting-join-alerts" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>

        <!-- Performance Settings -->
        <div class="settings-section">
          <h4 class="settings-section-title">
            <i class="fas fa-tachometer-alt"></i>
            Performance
          </h4>
          <div class="setting-item">
            <div class="setting-label">
              <div class="setting-name">Performance Mode</div>
              <div class="setting-description">Disable animations and effects</div>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="setting-performance-mode">
              <span class="toggle-slider"></span>
            </label>
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <div class="setting-name">Auto Complete</div>
              <div class="setting-description">Enable code auto-completion</div>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="setting-auto-complete" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Voice Chat Options Modal -->
  <div class="modal-overlay" id="voice-chat-options-modal">
    <div class="modal-container">
      <div class="modal-header">
        <h3 class="modal-title">Voice Chat Options</h3>
        <button class="modal-close" id="voice-chat-options-close-btn">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-content">
        <!-- Voice Chat Participants List -->
        <div class="voice-participants-section">
          <h4 class="voice-section-title">
            <i class="fas fa-users"></i>
            Voice Participants
          </h4>
          <div class="voice-participants-list" id="voice-participants-list">
            <!-- Voice participants will be populated dynamically -->
          </div>
        </div>

        <!-- Voice Chat Controls -->
        <div class="voice-controls-section">
          <h4 class="voice-section-title">
            <i class="fas fa-cog"></i>
            Voice Controls
          </h4>
          <div class="voice-control-item">
            <div class="voice-control-info">
              <div class="voice-control-name">Microphone</div>
              <div class="voice-control-description">Toggle your microphone on/off</div>
            </div>
            <button class="voice-control-btn" id="modal-mute-btn">
              <i class="fas fa-microphone"></i>
              Unmuted
            </button>
          </div>
          <div class="voice-control-item">
            <div class="voice-control-info">
              <div class="voice-control-name">Audio Output</div>
              <div class="voice-control-description">Deafen yourself to stop hearing others</div>
            </div>
            <button class="voice-control-btn" id="modal-deafen-btn">
              <i class="fas fa-volume-up"></i>
              Hearing
            </button>
          </div>
          <div class="voice-control-item">
            <div class="voice-control-info">
              <div class="voice-control-name">Leave Voice Chat</div>
              <div class="voice-control-description">Exit the voice chat completely</div>
            </div>
            <button class="voice-control-btn danger" id="modal-leave-voice-btn">
              <i class="fas fa-door-open"></i>
              Leave Call
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Socket.io -->
  <script src="/socket.io/socket.io.js"></script>

  <!-- Required JavaScript Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <!-- CodeMirror (reliable fallback) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/mode/javascript/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/mode/python/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/mode/htmlmixed/htmlmixed.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/mode/css/css.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/mode/clike/clike.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/mode/php/php.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/mode/ruby/ruby.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/mode/sql/sql.min.js"></script>

  <!-- Direct Monaco Editor Loading (attempt) -->
  <script src="https://unpkg.com/monaco-editor@latest/min/vs/loader.js"></script>
  <script>
    // Monaco uses AMD module system
    require.config({ paths: { 'vs': 'https://unpkg.com/monaco-editor@latest/min/vs' }});
    window.MonacoEnvironment = { getWorkerUrl: () => proxy };

    let proxy = URL.createObjectURL(new Blob([`
      self.MonacoEnvironment = {
        baseUrl: 'https://unpkg.com/monaco-editor@latest/min/'
      };
      importScripts('https://unpkg.com/monaco-editor@latest/min/vs/base/worker/workerMain.js');
    `], { type: 'text/javascript' }));
  </script>

  <script>
    // User and Room data
    const userId = '<%= req.user._id || req.user.id || req.user.googleId %>';
    const username = '<%= req.user.username || req.user.displayName || req.user.email.split("@")[0] %>';
    const roomId = '<%= roomData.id %>';
    const userPicture = '<%= req.user.picture || `https://ui-avatars.com/api/?name=${req.user.username || req.user.displayName || req.user.email.split("@")[0]}` %>';
    let currentLanguage = '<%= roomData.language %>';
    let currentFileIndex = 0;
    let editor = null;
    let socket = null;
    let remoteCursors = {};
    let performanceMode = localStorage.getItem('codecollab-performance-mode') === 'true';
    let files = <%- JSON.stringify(roomData.files) %>;
    // Variable to store the terminal input handler function
    let handleTerminalInput;
    // Flag to track local typing to prevent cursor conflicts
    let isLocalTyping = false;

    // AI Chat variables
    let currentAIModel = 'gemini-2.0-flash-exp';
    let aiConversationHistory = [];
    let isAIResponding = false;
    let aiUsageRemaining = null;
    let isProUser = <%= req.user && req.user.subscription && req.user.subscription.isPro ? 'true' : 'false' %>;

    // Function to update AI usage counter
    function updateAIUsageCounter() {
      const counter = document.getElementById('ai-usage-counter');
      if (!counter) return;
      
      if (isProUser) {
        counter.textContent = 'Pro User';
        counter.style.color = '#4CAF50';
      } else if (aiUsageRemaining !== null) {
        counter.textContent = `${aiUsageRemaining}/5 today`;
        counter.style.color = aiUsageRemaining > 0 ? '#ffc107' : '#dc3545';
      } else {
        counter.textContent = 'Loading...';
        counter.style.color = '#6c757d';
      }
    }

    // Edit Permission variables
    let isCurrentEditor = false;
    let currentEditor = null;
    let isOwner = '<%= roomData.createdBy === (req.user._id || req.user.id || req.user.googleId) ? "true" : "false" %>' === 'true';
    
    // Initialize edit permission state
    // Owner starts as the editor by default
    if (isOwner) {
      isCurrentEditor = true;
      currentEditor = userId;
    }

    // Initialize Socket.IO connection
    function initializeSocket() {
      socket = io({
        transports: ['websocket'],
        upgrade: false
      });

      // Socket connection events
      socket.on('connect', () => {
        console.log('Connected to server with socket ID:', socket.id);

        // Join the room
        socket.emit('join_room', {
          roomId,
          userId,
          username,
          picture: userPicture,
          language: currentLanguage
        });

        // Request current cursor positions
        socket.emit('request_cursor_positions', { roomId });
      });

      socket.on('disconnect', () => {
        console.log('Disconnected from server');
        // You might want to show a reconnection message
        addSystemMessage('Disconnected from server. Trying to reconnect...');
      });

      // Handle existing users data sent to new user
      socket.on('existing_user', (data) => {
        console.log('Existing user:', data);
        
        // Add existing user avatar to the list if not already there
        addRemoteAvatar(data.userId, data.username, data.picture);

        // Add existing user to participants list
        addParticipant(data.userId, data.username, data.picture, data.color);
      });

      // Room events
      socket.on('user_joined', (data) => {
        console.log('User joined:', data);
        const onlineCountEl = document.getElementById('online-count');
        const participantsCountEl = document.getElementById('participants-count');
        
        if (onlineCountEl) onlineCountEl.textContent = data.userCount || 1;
        if (participantsCountEl) participantsCountEl.textContent = data.userCount || 1;

        // Only add to UI if it's not the current user
        if (data.userId !== userId) {
          // Add user avatar to the list if not already there
          addRemoteAvatar(data.userId, data.username, data.picture);

          // Add user to participants list
          addParticipant(data.userId, data.username, data.picture, data.color);

          // Add system message to chat
          addSystemMessage(`${data.username} joined the room`);

          // Send our current cursor position to the new user
          if (socket && editor) {
            setTimeout(() => {
              socket.emit('cursor_move', {
                roomId,
                userId,
                username,
                cursorPosition: editor.getPosition()
              });
            }, 500);
          }
        } else {
          console.log('Ignoring own join event for participant list');
          // Initialize edit permissions for current user
          currentEditor = data.currentEditor;
          isOwner = data.isOwner;
          isCurrentEditor = (data.currentEditor === userId);
          
          // Update UI based on edit permissions
          updateEditButtons();
          
          // Request cursor positions after a short delay and with retry
          setTimeout(() => {
            console.log('Requesting cursor positions...');
            socket.emit('request_cursor_positions', { roomId });
            
            // Retry after another delay if we didn't get any cursors
            setTimeout(() => {
              if (Object.keys(remoteCursors).length === 0) {
                console.log('No cursors received, retrying...');
                socket.emit('request_cursor_positions', { roomId });
              }
            }, 2000);
          }, 1000);
        }
      });

      socket.on('user_left', (data) => {
        console.log('User left:', data);
        const onlineCountEl = document.getElementById('online-count');
        const participantsCountEl = document.getElementById('participants-count');
        
        if (onlineCountEl) onlineCountEl.textContent = data.userCount || 1;
        if (participantsCountEl) participantsCountEl.textContent = data.userCount || 1;

        // Remove user avatar from the list
        removeRemoteAvatar(data.userId);

        // Remove user cursor
        removeRemoteCursor(data.userId);

        // Remove from participants list
        removeParticipant(data.userId);

        // Add system message to chat
        addSystemMessage(`${data.username} left the room`);
      });

      // Code events
      socket.on('code_updated', (data) => {
        if (!editor) return;
        if (data.userId === userId) return;
        if (isLocalTyping) return; // Don't overwrite while local user is typing

        const currentValue = editor.getValue();
        if (currentValue !== data.code) {
          const position = editor.getPosition();
          const selections = editor.getSelections();
          editor.setValue(data.code);
          if (position) editor.setPosition(position);
          if (selections) editor.setSelections(selections);
          
          // Update all remote cursor positions after code change
          setTimeout(() => {
            updateAllRemoteCursorPositions();
          }, 50);
        }
      });

      // Language events
      socket.on('language_changed', (data) => {
        if (data.userId === userId) return;

        currentLanguage = data.language;
        document.getElementById('selected-language').textContent = data.language;

        // Update editor language
        monaco.editor.setModelLanguage(editor.getModel(), mapLanguage(data.language));

        // Add system message to chat
        addSystemMessage(`${data.username} changed language to ${data.language}`);
      });

      // Cursor events
      socket.on('cursor_updated', (data) => {
        if (data.userId === userId) return;
        
        console.log('Received cursor update from:', data.username, 'Position:', data.cursorPosition);
        
        // Wait for editor to be ready before processing cursor updates
        if (!editor) {
          console.log('Editor not ready, delaying cursor update...');
          setTimeout(() => {
            if (editor) {
              updateRemoteCursor(data.userId, data.username, data.cursorPosition, data.color);
            }
          }, 1000);
        } else {
          updateRemoteCursor(data.userId, data.username, data.cursorPosition, data.color);
        }
      });

      // Current cursors positions (after requesting)
      socket.on('cursor_positions', (data) => {
        const { cursors } = data;
        console.log('Received cursor positions:', cursors.length, 'cursors');

        // Wait for editor to be ready before processing cursor positions
        if (!editor) {
          console.log('Editor not ready, delaying cursor positions...');
          setTimeout(() => {
            if (editor) {
              for (const cursor of cursors) {
                if (cursor.userId !== userId) {
                  console.log('Setting up cursor for:', cursor.username);
                  updateRemoteCursor(cursor.userId, cursor.username, cursor.position, cursor.color);
                }
              }
            }
          }, 1000);
        } else {
          // Update all remote cursors immediately
          for (const cursor of cursors) {
            if (cursor.userId !== userId) {
              console.log('Setting up cursor for:', cursor.username);
              updateRemoteCursor(cursor.userId, cursor.username, cursor.position, cursor.color);
            }
          }
        }
      });

      // Chat messages
      socket.on('new_message', (data) => {
        const isOwnMessage = data.userId === userId;
        addChatMessage(data, isOwnMessage);
      });

      // Run code results
      socket.on('code_result', (data) => {
        displayCodeResult(data);
        
        // Re-enable run button
        const runCodeBtn = document.getElementById('run-code');
        if (runCodeBtn) {
          runCodeBtn.disabled = false;
          runCodeBtn.innerHTML = '<i class="fas fa-play"></i> Run';
        }
      });

      // New file created by another user
      socket.on('file_added', (data) => {
        if (data.userId === userId) return;

        // Add the file to our local files array
        const newFileIndex = files.length;
        files.push(data.file);

        // Add file to the list
        const filesList = document.getElementById('files-list');
        const li = document.createElement('li');
        li.setAttribute('data-file-index', newFileIndex);

        // Determine icon based on file type
        let iconClass = 'far fa-file-code';
        if (data.file.type === 'javascript') iconClass = 'fab fa-js-square';
        else if (data.file.type === 'html') iconClass = 'fab fa-html5';
        else if (data.file.type === 'css') iconClass = 'fab fa-css3-alt';
        else if (data.file.type === 'python') iconClass = 'fab fa-python';

        li.innerHTML = `<i class="file-icon ${iconClass}"></i> ${data.file.name}`;
        filesList.appendChild(li);

        // Add click event
        li.addEventListener('click', function() {
          const fileIndex = parseInt(this.getAttribute('data-file-index'));
          switchFile(fileIndex);
        });

        // Add system message to chat
        addSystemMessage(`${data.username} created a new file: ${data.file.name}`);
      });

      // File saved by another user
      socket.on('file_saved', (data) => {
        if (data.userId === userId) return;
        addSystemMessage(`${data.username} saved ${data.fileName}`);
      });

      // File closed by another user
      socket.on('file_closed', (data) => {
        if (data.userId === userId) return;
        addSystemMessage(`${data.username} closed ${data.fileName}`);
      });

      // Bash command result
      socket.on('bash_result', (data) => {
        // Update main terminal (existing functionality)
        const terminal = document.getElementById('terminal');
        const inputDiv = terminal.querySelector('.terminal-input');

        // Remove the terminal input temporarily
        if (inputDiv) {
          inputDiv.remove();
        }

        // Add the command output
        if (data.error) {
          terminal.innerHTML += `<span style="color: #ff5252;">${data.error}</span>\n`;
        } else if (data.result) {
          terminal.innerHTML += `${data.result}\n`;
        }

        // Add back the terminal input
        terminal.innerHTML += `<div class="terminal-input">
          <span class="terminal-input-prompt">$</span>
          <input type="text" class="terminal-input-field" id="terminal-input" placeholder="Enter bash command...">
        </div>`;

        // Update terminal sidebar as well
        const terminalOutput = document.getElementById('terminal-output');
        if (terminalOutput) {
          const resultLine = document.createElement('div');
          resultLine.className = 'terminal-line';
          
          if (data.error) {
            resultLine.style.color = '#ff5252';
            resultLine.textContent = data.error;
          } else if (data.result) {
            resultLine.style.color = '#e0e0e0';
            resultLine.textContent = data.result;
          }
          
          terminalOutput.appendChild(resultLine);
          
          // Scroll to bottom
          terminalOutput.scrollTop = terminalOutput.scrollHeight;
        }

        // Reattach event listener to new terminal input
        document.getElementById('terminal-input').addEventListener('keydown', handleTerminalInput);

        // Scroll terminal to bottom
        terminal.scrollTop = terminal.scrollHeight;
      });

      // Edit Permission Events
      socket.on('edit_permission_requested', (data) => {
        const { fromUserId, fromUsername } = data;
        
        // Show confirmation dialog
        if (confirm(`${fromUsername} is requesting edit access. Grant permission?`)) {
          // Grant permission
          socket.emit('respond_edit_permission', {
            roomId: roomId,
            userId: userId,
            grantedUserId: fromUserId,
            granted: true,
            username: username
          });
        } else {
          // Deny permission
          socket.emit('respond_edit_permission', {
            roomId: roomId,
            userId: userId,
            grantedUserId: fromUserId,
            granted: false,
            username: username
          });
        }
      });

      socket.on('edit_permission_granted', (data) => {
        isCurrentEditor = data.isEditor;
        updateEditButtons();
        
        showNotification('Edit permission granted!', 'success');
        if (data.grantedBy) {
          addSystemMessage(`You have been granted edit permission by ${data.grantedBy}`);
        }
      });

      socket.on('edit_permission_denied', (data) => {
        showNotification('Edit request denied', 'error');
        if (data.deniedBy) {
          addSystemMessage(`Your edit request was denied by ${data.deniedBy}`);
        }
      });

      socket.on('edit_permission_revoked', (data) => {
        isCurrentEditor = false;
        updateEditButtons();
        
        showNotification('Edit permission revoked', 'warning');
        addSystemMessage(data.message);
      });

      socket.on('edit_request_sent', (data) => {
        showNotification('Edit request sent', 'info');
        addSystemMessage(data.message);
      });

      socket.on('editor_changed', (data) => {
        currentEditor = data.newEditor;
        
        // Update UI to show who is currently editing
        if (data.newEditor === userId) {
          isCurrentEditor = true;
        } else {
          isCurrentEditor = false;
        }
        
        updateEditButtons();
        addSystemMessage(`${data.newEditorName} is now the editor`);
      });
    }

    // ============== WEBRTC VOICE CHAT FUNCTIONALITY ==============
    
    // Voice chat state variables
    let isInVoiceChat = false;
    let isMuted = false;
    let isDeafened = false;
    let localAudioStream = null;
    let peerConnections = new Map(); // Map of userId -> RTCPeerConnection
    let remoteAudioStreams = new Map(); // Map of userId -> MediaStream
    let voiceParticipants = []; // Array to store voice participants data
    
    // WebRTC configuration
    const rtcConfiguration = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" }
      ]
    };

    // Voice chat UI elements
    const joinVoiceBtn = document.getElementById('join-voice-btn');
    const muteBtn = document.getElementById('mute-btn');
    const deafenBtn = document.getElementById('deafen-btn');
    const leaveVoiceBtn = document.getElementById('leave-voice-btn');
    const voiceChatOptionsBtn = document.getElementById('voice-chat-options-btn');
    const voiceIndicator = document.getElementById('voice-participants-indicator');

    // Add event listeners for voice chat buttons
    function setupVoiceChatEventListeners() {
      if (joinVoiceBtn) {
        joinVoiceBtn.addEventListener('click', joinVoiceChat);
      }
      
      if (muteBtn) {
        muteBtn.addEventListener('click', toggleMute);
      }
      
      if (deafenBtn) {
        deafenBtn.addEventListener('click', toggleDeafen);
      }
      
      if (leaveVoiceBtn) {
        leaveVoiceBtn.addEventListener('click', leaveVoiceChat);
      }
    }

    // Initialize voice chat socket event listeners
    function initializeVoiceChatSocket() {
      if (!socket) {
        console.error('Socket not initialized');
        return;
      }

      // Voice user joined
      socket.on('voice_user_joined', (data) => {
        console.log('Voice user joined:', data);
        updateVoiceParticipantsUI(data.participants);
        
        // If we're already in voice chat, establish peer connection
        if (isInVoiceChat && data.userId !== userId) {
          console.log('Initiating peer connection to new user:', data.userId);
          setTimeout(() => createPeerConnection(data.userId), 1000);
        }
      });

      // Handle existing voice users when joining
      socket.on('existing_voice_user', (data) => {
        console.log('Existing voice user:', data);
        
        // Add the existing voice user to UI
        addVoiceParticipantToUI(data);
        
        // If we're in voice chat, establish peer connection
        if (isInVoiceChat && data.userId !== userId) {
          console.log('Initiating peer connection to existing voice user:', data.userId);
          setTimeout(() => createPeerConnection(data.userId), 1000);
        }
      });

      // Voice user left
      socket.on('voice_user_left', (data) => {
        console.log('Voice user left:', data);
        updateVoiceParticipantsUI(data.participants);
        
        // Clean up peer connection
        if (peerConnections.has(data.userId)) {
          console.log('Closing peer connection for user:', data.userId);
          peerConnections.get(data.userId).close();
          peerConnections.delete(data.userId);
        }
        
        // Remove remote audio element
        const audioId = `remote-audio-${data.userId}`;
        const audio = document.getElementById(audioId);
        if (audio) {
          audio.srcObject = null;
          audio.remove();
          console.log('Removed audio element for user:', data.userId);
        }
        
        if (remoteAudioStreams.has(data.userId)) {
          remoteAudioStreams.delete(data.userId);
        }
      });

      // Voice join success
      socket.on('voice_join_success', (data) => {
        console.log('Voice join success:', data);
        isInVoiceChat = true;
        updateVoiceChatUI();
        updateVoiceParticipantsUI(data.participants);
        
        // Create peer connections for existing participants (excluding self)
        const otherParticipants = data.participants.filter(p => p.userId !== userId);
        console.log('Other participants to connect to:', otherParticipants);
        
        otherParticipants.forEach((participant, index) => {
          // Stagger the connections to avoid race conditions
          setTimeout(() => {
            console.log('Creating peer connection to existing participant:', participant.userId);
            createPeerConnection(participant.userId);
          }, (index + 1) * 1500);
        });
      });

      // Voice join error
      socket.on('voice_join_error', (data) => {
        console.error('Voice join error:', data.message);
        
        if (data.requiresPro) {
          // Show pro upgrade prompt for voice chat
          showProUpgradeModal('voice_chat', data.message);
        } else {
          showNotification('Failed to join voice chat: ' + data.message, 'error');
        }
      });

      // Voice chat trial status
      socket.on('voice_trial_status', (data) => {
        console.log('Voice trial status:', data);
        if (data.isTrialUser) {
          showNotification(`Voice Chat Trial: ${data.remainingMinutes} minutes remaining (${data.usedMinutes}/${data.totalTrialMinutes} used)`, 'info', 5000);
        }
      });

      // Voice chat trial update
      socket.on('voice_trial_update', (data) => {
        console.log('Voice trial update:', data);
        if (data.remainingMinutes === 0) {
          showNotification('Voice chat trial expired! Upgrade to Pro for unlimited voice communication.', 'warning', 8000);
        } else if (data.remainingMinutes <= 5) {
          showNotification(`Voice Chat Trial: Only ${data.remainingMinutes} minutes remaining!`, 'warning', 5000);
        } else {
          showNotification(`Voice Chat Session: Used ${data.sessionMinutes} minutes. ${data.remainingMinutes} minutes remaining.`, 'info', 3000);
        }
      });

      // Voice leave success
      socket.on('voice_leave_success', (data) => {
        console.log('Voice leave success');
        cleanupVoiceChat();
      });

      // User muted/unmuted
      socket.on('voice_user_muted', (data) => {
        console.log('User muted status:', data);
        // Update UI to show user's mute status if needed
      });

      // User deafened/undeafened
      socket.on('voice_user_deafened', (data) => {
        console.log('User deafened status:', data);
        // Update UI to show user's deafen status if needed
      });

      // WebRTC signaling events
      socket.on('webrtc_offer_received', async (data) => {
        console.log('Received WebRTC offer from:', data.fromUserId);
        console.log('Offer data:', data.offer);
        await handleOffer(data.fromUserId, data.offer);
      });

      socket.on('webrtc_answer_received', async (data) => {
        console.log('Received WebRTC answer from:', data.fromUserId);
        console.log('Answer data:', data.answer);
        await handleAnswer(data.fromUserId, data.answer);
      });

      socket.on('webrtc_ice_candidate_received', async (data) => {
        console.log('Received ICE candidate from:', data.fromUserId);
        console.log('ICE candidate data:', data.candidate);
        await handleIceCandidate(data.fromUserId, data.candidate);
      });
    }

    // Join voice chat function
    async function joinVoiceChat() {
      try {
        console.log('Requesting microphone access...');
        
        // Request microphone access
        localAudioStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });
        
        console.log('Microphone access granted');
        
        // Join voice chat room via socket
        socket.emit('join_voice_chat', {
          roomId: roomId,
          userId: userId,
          username: username
        });
        
        showNotification('Joining voice chat...', 'info');
        
      } catch (error) {
        console.error('Error accessing microphone:', error);
        showNotification('Failed to access microphone. Please check permissions.', 'error');
      }
    }

    // Leave voice chat function
    function leaveVoiceChat() {
      console.log('Leaving voice chat...');
      
      // Notify server
      socket.emit('leave_voice_chat', {
        roomId: roomId,
        userId: userId,
        username: username
      });
      
      cleanupVoiceChat();
      showNotification('Left voice chat', 'info');
    }

    // Cleanup voice chat resources
    function cleanupVoiceChat() {
      isInVoiceChat = false;
      isMuted = false;
      isDeafened = false;
      
      // Stop local audio stream
      if (localAudioStream) {
        localAudioStream.getTracks().forEach(track => track.stop());
        localAudioStream = null;
      }
      
      // Remove remote audio elements
      remoteAudioStreams.forEach((stream, userId) => {
        const audioId = `remote-audio-${userId}`;
        const audio = document.getElementById(audioId);
        if (audio) {
          audio.srcObject = null;
          audio.remove();
        }
      });
      
      // Close all peer connections
      peerConnections.forEach(pc => pc.close());
      peerConnections.clear();
      remoteAudioStreams.clear();
      
      // Update UI
      updateVoiceChatUI();
      updateVoiceParticipantsUI([]);
    }

    // Toggle mute function
    function toggleMute() {
      if (!localAudioStream) return;
      
      isMuted = !isMuted;
      
      // Toggle audio track
      localAudioStream.getAudioTracks().forEach(track => {
        track.enabled = !isMuted;
      });
      
      // Update UI
      updateVoiceChatUI();
      updateVoiceChatOptionsModalControls();
      
      // Notify other participants
      socket.emit('voice_mute_toggle', {
        roomId: roomId,
        userId: userId,
        isMuted: isMuted
      });
      
      showNotification(isMuted ? 'Microphone muted' : 'Microphone unmuted', 'info');
    }

    // Toggle deafen function
    function toggleDeafen() {
      isDeafened = !isDeafened;
      
      // Update volume for all remote audio elements
      remoteAudioStreams.forEach((stream, userId) => {
        const audioId = `remote-audio-${userId}`;
        const audio = document.getElementById(audioId);
        if (audio) {
          audio.volume = isDeafened ? 0 : 1;
          audio.muted = isDeafened;
        }
      });
      
      // Update UI
      updateVoiceChatUI();
      updateVoiceChatOptionsModalControls();
      
      // Notify other participants
      socket.emit('voice_deafen_toggle', {
        roomId: roomId,
        userId: userId,
        isDeafened: isDeafened
      });
      
      showNotification(isDeafened ? 'Audio deafened' : 'Audio enabled', 'info');
    }

    // Create peer connection for a user
    async function createPeerConnection(targetUserId) {
      if (peerConnections.has(targetUserId)) {
        console.log('Peer connection already exists for:', targetUserId);
        return peerConnections.get(targetUserId);
      }
      
      console.log('Creating peer connection for:', targetUserId);
      
      const pc = new RTCPeerConnection(rtcConfiguration);
      peerConnections.set(targetUserId, pc);
      
      // Add local stream first
      if (localAudioStream) {
        console.log('Adding local audio tracks to peer connection for:', targetUserId);
        localAudioStream.getTracks().forEach(track => {
          pc.addTrack(track, localAudioStream);
          console.log('Added track:', track.kind);
        });
      } else {
        console.error('No local audio stream available for peer connection');
        return;
      }
      
      // Handle remote stream
      pc.ontrack = (event) => {
        console.log('Received remote track from:', targetUserId);
        
        const [remoteStream] = event.streams;
        remoteAudioStreams.set(targetUserId, remoteStream);
        
        // Create audio element to play remote stream
        const audioId = `remote-audio-${targetUserId}`;
        let audio = document.getElementById(audioId);
        
        if (!audio) {
          audio = document.createElement('audio');
          audio.id = audioId;
          audio.autoplay = true;
          audio.controls = false;
          audio.style.display = 'none';
          audio.playsInline = true;
          document.body.appendChild(audio);
        }
        
        audio.srcObject = remoteStream;
        audio.volume = isDeafened ? 0 : 1;
        
        // Ensure audio plays
        audio.play().then(() => {
          console.log('Remote audio playing for:', targetUserId);
        }).catch(e => {
          console.log('Auto-play prevented, user interaction required:', e);
          
          // Show a notification to user that they need to interact to enable audio
          showNotification('Click anywhere to enable voice chat audio', 'warning');
          
          // Add click handler to enable audio
          const enableAudio = () => {
            audio.play().then(() => {
              console.log('Remote audio enabled for user:', targetUserId);
              document.removeEventListener('click', enableAudio);
            }).catch(console.error);
          };
          document.addEventListener('click', enableAudio, { once: true });
        });
        
        console.log('Remote audio stream set up for user:', targetUserId);
      };
      
      // Handle ICE candidates
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          console.log('Sending ICE candidate to:', targetUserId);
          socket.emit('webrtc_ice_candidate', {
            roomId: roomId,
            targetUserId: targetUserId,
            fromUserId: userId,
            candidate: event.candidate
          });
        } else {
          console.log('All ICE candidates have been sent to:', targetUserId);
        }
      };

      // Handle connection state changes
      pc.onconnectionstatechange = () => {
        console.log('Connection state change for', targetUserId, ':', pc.connectionState);
        if (pc.connectionState === 'connected') {
          console.log('âœ… Successfully connected to:', targetUserId);
        } else if (pc.connectionState === 'failed') {
          console.log('âŒ Connection failed to:', targetUserId);
        }
      };
      
      // Create and send offer after a small delay to ensure everything is set up
      try {
        await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
        
        console.log('Creating offer for:', targetUserId);
        const offer = await pc.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: false
        });
        
        await pc.setLocalDescription(offer);
        console.log('Set local description, sending offer to:', targetUserId);
        
        socket.emit('webrtc_offer', {
          roomId: roomId,
          targetUserId: targetUserId,
          fromUserId: userId,
          offer: offer
        });
        
      } catch (error) {
        console.error('Error creating/sending offer:', error);
      }
      
      return pc;
    }

    // Handle received offer
    async function handleOffer(fromUserId, offer) {
      try {
        console.log('Handling offer from:', fromUserId);
        
        let pc = peerConnections.get(fromUserId);
        if (!pc) {
          console.log('Creating new peer connection for incoming offer from:', fromUserId);
          pc = new RTCPeerConnection(rtcConfiguration);
          peerConnections.set(fromUserId, pc);
          
          // Add local stream
          if (localAudioStream) {
            console.log('Adding local audio tracks to new peer connection for:', fromUserId);
            localAudioStream.getTracks().forEach(track => {
              pc.addTrack(track, localAudioStream);
              console.log('Added track:', track.kind);
            });
          } else {
            console.error('No local audio stream available for incoming offer');
          }
          
          // Handle remote stream
          pc.ontrack = (event) => {
            console.log('Received remote track from:', fromUserId);
            const [remoteStream] = event.streams;
            remoteAudioStreams.set(fromUserId, remoteStream);
            
            // Create audio element to play remote stream
            const audioId = `remote-audio-${fromUserId}`;
            let audio = document.getElementById(audioId);
            
            if (!audio) {
              audio = document.createElement('audio');
              audio.id = audioId;
              audio.autoplay = true;
              audio.controls = false;
              audio.style.display = 'none';
              document.body.appendChild(audio);
            }
            
            audio.srcObject = remoteStream;
            audio.volume = isDeafened ? 0 : 1;
            
            // Ensure audio plays
            audio.play().catch(e => {
              console.log('Auto-play prevented, user interaction required:', e);
              // Show a notification to user that they need to interact to enable audio
              showNotification('Click anywhere to enable voice chat audio', 'warning');
              
              // Add click handler to enable audio
              const enableAudio = () => {
                audio.play().then(() => {
                  console.log('Remote audio enabled for user:', fromUserId);
                  document.removeEventListener('click', enableAudio);
                }).catch(console.error);
              };
              document.addEventListener('click', enableAudio, { once: true });
            });
            
            console.log('Remote audio stream set up for user:', fromUserId);
          };
          
          // Handle ICE candidates
          pc.onicecandidate = (event) => {
            if (event.candidate) {
              console.log('Sending ICE candidate to:', fromUserId);
              socket.emit('webrtc_ice_candidate', {
                roomId: roomId,
                targetUserId: fromUserId,
                fromUserId: userId,
                candidate: event.candidate
              });
            }
          };

          // Handle connection state changes
          pc.onconnectionstatechange = () => {
            console.log('Connection state change for', fromUserId, ':', pc.connectionState);
            if (pc.connectionState === 'connected') {
              console.log('âœ… Successfully connected to:', fromUserId);
            } else if (pc.connectionState === 'failed') {
              console.log('âŒ Connection failed to:', fromUserId);
            }
          };
        }
        
        console.log('Setting remote description for offer from:', fromUserId);
        await pc.setRemoteDescription(offer);
        
        // Create and send answer
        console.log('Creating answer for:', fromUserId);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        
        console.log('Sending answer to:', fromUserId);
        socket.emit('webrtc_answer', {
          roomId: roomId,
          targetUserId: fromUserId,
          fromUserId: userId,
          answer: answer
        });
        
      } catch (error) {
        console.error('Error handling offer from', fromUserId, ':', error);
      }
    }

    // Handle received answer
    async function handleAnswer(fromUserId, answer) {
      try {
        const pc = peerConnections.get(fromUserId);
        if (pc) {
          await pc.setRemoteDescription(answer);
          console.log('Set remote description for answer from:', fromUserId);
        }
      } catch (error) {
        console.error('Error handling answer:', error);
      }
    }

    // Handle received ICE candidate
    async function handleIceCandidate(fromUserId, candidate) {
      try {
        const pc = peerConnections.get(fromUserId);
        if (pc) {
          await pc.addIceCandidate(candidate);
          console.log('Added ICE candidate from:', fromUserId);
        }
      } catch (error) {
        console.error('Error handling ICE candidate:', error);
      }
    }

    // Update voice chat UI
    function updateVoiceChatUI() {
      if (!joinVoiceBtn || !muteBtn || !deafenBtn || !leaveVoiceBtn) return;
      
      if (isInVoiceChat) {
        joinVoiceBtn.style.display = 'none';
        muteBtn.style.display = 'inline-block';
        deafenBtn.style.display = 'inline-block';
        leaveVoiceBtn.style.display = 'inline-block';
        if (voiceChatOptionsBtn) voiceChatOptionsBtn.style.display = 'inline-block';
        
        // Update button states
        muteBtn.className = isMuted ? 'btn btn-sm btn-outline-danger voice-muted' : 'btn btn-sm btn-outline-danger voice-connected';
        muteBtn.innerHTML = isMuted ? '<i class="fas fa-microphone-slash"></i> Unmute' : '<i class="fas fa-microphone"></i> Mute';
        muteBtn.title = isMuted ? 'Unmute Microphone' : 'Mute Microphone';
        
        deafenBtn.className = isDeafened ? 'btn btn-sm btn-outline-danger voice-deafened' : 'btn btn-sm btn-outline-danger voice-connected';
        deafenBtn.innerHTML = isDeafened ? '<i class="fas fa-volume-mute"></i> Undeafen' : '<i class="fas fa-volume-up"></i> Deafen';
        deafenBtn.title = isDeafened ? 'Enable Audio' : 'Deafen Audio';
        
      } else {
        joinVoiceBtn.style.display = 'inline-block';
        muteBtn.style.display = 'none';
        deafenBtn.style.display = 'none';
        leaveVoiceBtn.style.display = 'none';
        if (voiceChatOptionsBtn) voiceChatOptionsBtn.style.display = 'none';
      }
    }

    // Update voice participants indicator
    function updateVoiceParticipantsUI(participants) {
      if (!voiceIndicator) return;
      
      // Store participants data for the modal
      voiceParticipants = participants || [];
      
      const count = participants ? participants.length : 0;
      if (count > 0) {
        voiceIndicator.textContent = count;
        voiceIndicator.style.display = 'flex';
      } else {
        voiceIndicator.style.display = 'none';
      }
      
      // Update voice participants modal if it's open
      updateVoiceParticipantsModal();
    }

    // Add individual voice participant to UI (for existing users)
    function addVoiceParticipantToUI(participant) {
      if (!participant) return;
      
      // Check if participant already exists in the list
      const existingIndex = voiceParticipants.findIndex(p => p.userId === participant.userId);
      
      if (existingIndex === -1) {
        // Add new participant to the list
        voiceParticipants.push(participant);
        
        // Update voice indicator count
        if (voiceIndicator) {
          voiceIndicator.textContent = voiceParticipants.length;
          voiceIndicator.style.display = 'flex';
        }
        
        // Update voice participants modal if it's open
        updateVoiceParticipantsModal();
        
        console.log('Added voice participant to UI:', participant.username);
      }
    }

    // Update voice participants modal content
    function updateVoiceParticipantsModal() {
      const voiceParticipantsList = document.getElementById('voice-participants-list');
      
      if (!voiceParticipantsList) return;
      
      // Clear current list
      voiceParticipantsList.innerHTML = '';
      
      if (voiceParticipants.length === 0) {
        // Show no participants message
        const noParticipants = document.createElement('div');
        noParticipants.className = 'no-voice-participants';
        noParticipants.innerHTML = `
          <i class="fas fa-microphone-slash"></i>
          <p>No one is currently in voice chat</p>
        `;
        voiceParticipantsList.appendChild(noParticipants);
      } else {
        // Show participants list
        voiceParticipants.forEach(participant => {
          const participantCard = document.createElement('div');
          participantCard.className = 'voice-participant-card';
          participantCard.innerHTML = `
            <img src="${participant.picture || `https://ui-avatars.com/api/?name=${participant.username}`}" 
                 alt="${participant.username}'s avatar" class="voice-participant-avatar">
            <div class="voice-participant-info">
              <div class="voice-participant-name">${participant.username}${participant.userId === userId ? ' (You)' : ''}</div>
              <div class="voice-participant-status">
                <span class="voice-status-indicator ${participant.muted ? 'muted' : ''}${participant.deafened ? 'deafened' : ''}"></span>
                ${participant.muted ? 'Muted' : participant.deafened ? 'Deafened' : 'Speaking'}
              </div>
            </div>
          `;
          voiceParticipantsList.appendChild(participantCard);
        });
      }
    }

    // Update voice chat modal controls to reflect current state
    function updateVoiceChatOptionsModalControls() {
      const modalMuteBtn = document.getElementById('modal-mute-btn');
      const modalDeafenBtn = document.getElementById('modal-deafen-btn');
      
      if (modalMuteBtn) {
        modalMuteBtn.className = isMuted ? 'voice-control-btn active' : 'voice-control-btn';
        modalMuteBtn.innerHTML = isMuted ? '<i class="fas fa-microphone-slash"></i> Muted' : '<i class="fas fa-microphone"></i> Unmuted';
      }
      
      if (modalDeafenBtn) {
        modalDeafenBtn.className = isDeafened ? 'voice-control-btn active' : 'voice-control-btn';
        modalDeafenBtn.innerHTML = isDeafened ? '<i class="fas fa-volume-mute"></i> Deafened' : '<i class="fas fa-volume-up"></i> Hearing';
      }
    }

    // ============== END WEBRTC VOICE CHAT FUNCTIONALITY ==============

    // Initialize editors with priority fallback approach
    function initializeEditor() {
  console.log('Initializing Monaco Editor...');

      // Register completion provider for all languages
      const languages = ['javascript', 'typescript', 'python', 'java', 'cpp', 'csharp', 'php', 'ruby', 'go', 'rust', 'html', 'css'];
      
      languages.forEach(language => {
        monaco.languages.registerCompletionItemProvider(language, {
          triggerCharacters: ['.', ' ', '(', '{', '[', '\n', '_', '-'],
          provideCompletionItems: async function (model, position) {
            try {
              const word = model.getWordUntilPosition(position);
              const range = {
                startLineNumber: position.lineNumber,
                endLineNumber: position.lineNumber,
                startColumn: word.startColumn,
                endColumn: word.endColumn
              };

              // Get context around the cursor (more context for better AI suggestions)
              const startLine = Math.max(1, position.lineNumber - 10);
              const endLine = Math.min(model.getLineCount(), position.lineNumber + 3);
              const contextLines = [];
              
              for (let i = startLine; i <= endLine; i++) {
                contextLines.push(model.getLineContent(i));
              }
              
              const context = contextLines.join('\n');
              const currentLine = model.getLineContent(position.lineNumber);
              const textBeforeCursor = currentLine.substring(0, position.column - 1);
              const fullCode = model.getValue();
              
              // Check if user typed 1-4 words (better trigger for AI)
              const words = textBeforeCursor.trim().split(/\s+/);
              const lastWord = word.word || '';
              const isShortInput = words.length <= 4 && lastWord.length >= 1;
              
              // More aggressive caching for better performance
              const cacheKey = `${language}-${textBeforeCursor.trim()}-${fullCode.slice(-200)}`;
              
              // Check cache first
              if (autocompleteCache.has(cacheKey)) {
                return autocompleteCache.get(cacheKey);
              }

              // For very short inputs or common patterns, provide immediate suggestions
              if (lastWord.length >= 1 && lastWord.length <= 4) {
                // Debounce requests for short inputs (faster response)
                if (lastRequest) {
                  clearTimeout(lastRequest);
                }

                return new Promise((resolve) => {
                  lastRequest = setTimeout(async () => {
                    try {
                      if (isAutocompleting) {
                        resolve({ suggestions: [] });
                        return;
                      }

                      isAutocompleting = true;

                      // Show a loading indicator for AI suggestions
                      showAILoadingIndicator(true);

                      const response = await fetch('/api/ai-autocomplete', {
                        method: 'POST',
                        headers: {
                          'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                          language: language,
                          context: context,
                          currentLine: currentLine,
                          cursorPosition: position.column - 1,
                          textBeforeCursor: textBeforeCursor,
                          fullCode: fullCode.length > 2000 ? fullCode.slice(-2000) : fullCode, // Send last 2000 chars for context
                          isShortInput: isShortInput,
                          wordCount: words.length
                        })
                      });

                      showAILoadingIndicator(false);

                      if (!response.ok) {
                        resolve({ suggestions: [] });
                        return;
                      }

                      const data = await response.json();
                      const suggestions = data.suggestions || [];

                      // Format suggestions for Monaco with enhanced priority for AI suggestions
                      const monacoSuggestions = suggestions.map((suggestion, index) => ({
                        label: suggestion.label || suggestion.text,
                        kind: getCompletionKind(suggestion.type || 'snippet'),
                        documentation: {
                          value: `ðŸ¤– **AI Suggestion**\n\n${suggestion.documentation || suggestion.description || 'Intelligent code completion'}`,
                          isTrusted: true
                        },
                        insertText: suggestion.insertText || suggestion.text,
                        range: range,
                        sortText: `0000${index}`, // High priority for AI suggestions
                        detail: `ðŸ¤– ${suggestion.detail || 'AI Completion'}`,
                        preselect: index === 0, // Preselect first AI suggestion
                        command: {
                          id: 'ai-autocomplete-accepted',
                          title: 'AI Autocomplete Accepted'
                        }
                      }));

                      // Add some common code patterns if AI didn't provide many suggestions
                      if (monacoSuggestions.length < 3 && isShortInput) {
                        const commonPatterns = getCommonPatterns(language, textBeforeCursor, lastWord);
                        monacoSuggestions.push(...commonPatterns);
                      }

                      // Cache the result
                      autocompleteCache.set(cacheKey, { suggestions: monacoSuggestions });
                      
                      // Clear old cache entries (keep only last 100 for better performance)
                      if (autocompleteCache.size > 100) {
                        const firstKey = autocompleteCache.keys().next().value;
                        autocompleteCache.delete(firstKey);
                      }

                      resolve({ suggestions: monacoSuggestions });
                    } catch (error) {
                      console.error('AI autocomplete error:', error);
                      resolve({ suggestions: [] });
                    } finally {
                      isAutocompleting = false;
                      showAILoadingIndicator(false);
                    }
                  }, isShortInput ? 150 : 300); // Faster response for short inputs
                });
              }

              // For longer inputs, use standard autocomplete with longer debounce
              return { suggestions: [] };
            } catch (error) {
              console.error('Autocomplete provider error:', error);
              return { suggestions: [] };
            }
          }
        });
      });

      // Helper function to get common patterns based on language and context
      function getCommonPatterns(language, textBeforeCursor, lastWord) {
        const patterns = [];
        
        if (language === 'javascript' || language === 'typescript') {
          if (lastWord.toLowerCase().includes('func') || lastWord.toLowerCase().includes('fn')) {
            patterns.push({
              label: 'function declaration',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: 'function ${1:functionName}(${2:parameters}) {\n\t${3:// function body}\n\treturn ${4:value};\n}',
              documentation: 'Create a function declaration',
              detail: 'ðŸ“ Common Pattern'
            });
          }
          
          if (lastWord.toLowerCase().includes('const') || lastWord.toLowerCase().includes('let')) {
            patterns.push({
              label: 'arrow function',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: ' = (${1:params}) => {\n\t${2:// function body}\n\treturn ${3:value};\n};',
              documentation: 'Create an arrow function',
              detail: 'ðŸ“ Common Pattern'
            });
          }
          
          if (lastWord.toLowerCase().includes('if')) {
            patterns.push({
              label: 'if statement',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: 'if (${1:condition}) {\n\t${2:// code block}\n}',
              documentation: 'Create an if statement',
              detail: 'ðŸ“ Common Pattern'
            });
          }
        } else if (language === 'python') {
          if (lastWord.toLowerCase().includes('def')) {
            patterns.push({
              label: 'function definition',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: 'def ${1:function_name}(${2:parameters}):\n    """${3:docstring}"""\n    ${4:pass}',
              documentation: 'Create a Python function',
              detail: 'ðŸ“ Common Pattern'
            });
          }
          
          if (lastWord.toLowerCase().includes('class')) {
            patterns.push({
              label: 'class definition',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: 'class ${1:ClassName}:\n    """${2:docstring}"""\n    \n    def __init__(self, ${3:parameters}):\n        ${4:pass}',
              documentation: 'Create a Python class',
              detail: 'ðŸ“ Common Pattern'
            });
          }
        }
        
        return patterns;
      }

      // Helper function to map suggestion types to Monaco completion kinds
      function getCompletionKind(type) {
        const kindMap = {
          'method': monaco.languages.CompletionItemKind.Method,
          'function': monaco.languages.CompletionItemKind.Function,
          'class': monaco.languages.CompletionItemKind.Class,
          'variable': monaco.languages.CompletionItemKind.Variable,
          'property': monaco.languages.CompletionItemKind.Property,
          'keyword': monaco.languages.CompletionItemKind.Keyword,
          'snippet': monaco.languages.CompletionItemKind.Snippet,
          'text': monaco.languages.CompletionItemKind.Text,
          'module': monaco.languages.CompletionItemKind.Module,
          'constant': monaco.languages.CompletionItemKind.Constant,
          'enum': monaco.languages.CompletionItemKind.Enum,
          'interface': monaco.languages.CompletionItemKind.Interface
        };
        return kindMap[type] || monaco.languages.CompletionItemKind.Text;
      }

      // AI loading indicator
      function showAILoadingIndicator(show) {
        let indicator = document.getElementById('ai-loading-indicator');
        if (!indicator) {
          indicator = document.createElement('div');
          indicator.id = 'ai-loading-indicator';
          indicator.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 122, 255, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 10000;
            display: none;
            animation: pulse 1.5s infinite;
          `;
          indicator.innerHTML = 'ðŸ¤– AI thinking...';
          document.body.appendChild(indicator);
        }
        indicator.style.display = show ? 'block' : 'none';
      }

      // Enhanced Tab key behavior for accepting AI suggestions
      editor.addCommand(monaco.KeyCode.Tab, function() {
        console.log('Tab key pressed for AI autocomplete');
        const suggestController = editor.getContribution('editor.contrib.suggestController');
        
        console.log('Suggest controller:', suggestController);
        
        // Check if suggestion widget is open and visible
        if (suggestController && 
            suggestController.widget && 
            suggestController.widget.value && 
            suggestController.widget.value.state === 1) {
          
          console.log('Accepting selected suggestion with Tab');
          // Accept the currently selected suggestion
          suggestController.acceptSelectedSuggestion(false, true);
          return null; // Prevent default tab behavior
        }
        
        // If no suggestions are visible, trigger them and try to accept
        if (suggestController) {
          console.log('No suggestions visible, triggering and accepting first suggestion');
          
          // Get current word to check if we should trigger AI
          const position = editor.getPosition();
          const word = editor.getModel().getWordUntilPosition(position);
          const currentLine = editor.getModel().getLineContent(position.lineNumber);
          const textBeforeCursor = currentLine.substring(0, position.column - 1);
          
          // Only trigger AI if we have some text to work with
          if (word.word && word.word.length >= 1) {
            console.log('Triggering AI suggestions for word:', word.word);
            suggestController.triggerSuggest();
            
            // Try multiple times to catch the suggestions
            let attempts = 0;
            const maxAttempts = 3;
            
            const tryAcceptSuggestion = () => {
              attempts++;
              console.log(`Attempt ${attempts} to accept suggestion`);
              
              if (suggestController.widget && 
                  suggestController.widget.value && 
                  suggestController.widget.value.state === 1) {
                console.log('Found suggestions, accepting first one');
                suggestController.acceptSelectedSuggestion(false, true);
                return;
              }
              
              if (attempts < maxAttempts) {
                setTimeout(tryAcceptSuggestion, 100);
              } else {
                console.log('No suggestions found after multiple attempts, inserting tab');
                editor.trigger('keyboard', 'tab', null);
              }
            };
            
            // Start trying to accept suggestions after a brief delay
            setTimeout(tryAcceptSuggestion, 50);
            return null; // Prevent default tab behavior
          }
        }
        
        console.log('No word to complete, inserting regular tab');
        // No word to complete, insert regular tab
        editor.trigger('keyboard', 'tab', null);
      });

      // Add Ctrl+Space as an alternative trigger for AI suggestions
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Space, function() {
        const suggestController = editor.getContribution('editor.contrib.suggestController');
        if (suggestController) {
          suggestController.triggerSuggest();
        }
      });

      // Add visual indicator for AI suggestions
      editor.addAction({
        id: 'trigger-ai-autocomplete',
        label: 'Trigger AI Autocomplete',
        keybindings: [monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyK],
        run: function() {
          const suggestController = editor.getContribution('editor.contrib.suggestController');
          if (suggestController) {
            suggestController.triggerSuggest();
            showNotification('AI autocomplete triggered! Press Tab to accept suggestions.', 'info', 2000);
          }
        }
      });

      // Add visual indicator for AI suggestions
      editor.addAction({
        id: 'toggle-ai-autocomplete',
        label: 'Toggle AI Autocomplete',
        keybindings: [monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyI],
        run: function() {
          const isEnabled = editor.getOption(monaco.editor.EditorOption.suggest);
          editor.updateOptions({ 
            suggest: { 
              ...isEnabled,
              showMethods: !isEnabled.showMethods,
              showFunctions: !isEnabled.showFunctions,
              showKeywords: !isEnabled.showKeywords
            }
          });
          showNotification(
            `AI Autocomplete ${!isEnabled.showMethods ? 'enabled' : 'disabled'}`, 
            'info'
          );
        }
      });

      console.log('AI Autocomplete setup completed');
      
      // Show user instruction for AI autocomplete
      setTimeout(() => {
        showNotification('ðŸ’¡ AI Autocomplete: Type 1-4 words, press Tab to complete or Enter to accept first suggestion!', 'info', 6000);
      }, 2000);
    }

    // Initialize editors with priority fallback approach
    function initializeEditor() {
  console.log('Initializing Monaco Editor...');

  const files = <%- JSON.stringify(roomData.files) %>;
  const initialFile = files[currentFileIndex];
  const initialContent = initialFile.content || '// Start coding here...';

  // Make sure the container is visible before initializing
  const monacoContainer = document.getElementById('monaco-editor');
  monacoContainer.style.display = 'block';

  // Monaco uses AMD loader, so we need to wait for require to be available
  if (typeof require === 'function') {
    require.config({ paths: { 'vs': 'https://unpkg.com/monaco-editor@latest/min/vs' } });
    window.MonacoEnvironment = {
      getWorkerUrl: function (moduleId, label) {
        return proxy;
      }
    };
    let proxy = URL.createObjectURL(new Blob([`
      self.MonacoEnvironment = { baseUrl: 'https://unpkg.com/monaco-editor@latest/min/' };
      importScripts('https://unpkg.com/monaco-editor@latest/min/vs/base/worker/workerMain.js');
    `], { type: 'text/javascript' }));

    require(['vs/editor/editor.main'], function () {
      try {
        editor = monaco.editor.create(monacoContainer, {
          value: initialContent,
          language: mapLanguage(initialFile.type),
          theme: document.body.classList.contains('dark-mode') ? 'vs-dark' : 'vs',
          automaticLayout: true,
          fontSize: 14,
          minimap: { enabled: true },
          // Enhanced autocomplete configuration
          suggest: {
            showMethods: true,
            showFunctions: true,
            showKeywords: true,
            showVariables: true,
            showClasses: true,
            showProperties: true,
            showModules: true,
            showSnippets: true,
            showConstants: true,
            showEnums: true,
            showInterfaces: true,
            insertMode: 'replace',
            filterGraceful: true,
            snippetsPreventQuickSuggestions: false,
            localityBonus: true,
            shareSuggestSelections: true,
            showWords: false, // Disable word-based suggestions to prioritize AI
            preview: true,
            previewMode: 'prefix'
          },
          quickSuggestions: {
            other: true,
            comments: false,
            strings: false
          },
          suggestOnTriggerCharacters: true,
          acceptSuggestionOnCommitCharacter: true,
          acceptSuggestionOnEnter: 'on',
          tabCompletion: 'on',
          wordBasedSuggestions: false, // Disable to prioritize AI suggestions
          parameterHints: {
            enabled: true,
            cycle: true
          },
          // Enable IntelliSense features
          hover: {
            enabled: true,
            delay: 300,
            sticky: true
          },
          lightbulb: {
            enabled: true
          },
          // Enhanced keyboard support for suggestions
          tabIndex: 0,
          selectOnLineNumbers: true,
          roundedSelection: false,
          readOnly: !isCurrentEditor, // Set based on edit permission
          cursorStyle: 'line',
          automaticLayout: true,
          // More aggressive suggestion settings for Tab completion
          quickSuggestionsDelay: 100,
          suggestSelection: 'first',
          acceptSuggestionOnEnter: 'on'
        });

        editor.onDidChangeModelContent(() => {
          // Only allow code changes if user has edit permission
          if (!isCurrentEditor) {
            return;
          }
          
          isLocalTyping = true;
          if (socket) {
            const position = editor.getPosition();
            socket.emit('code_change', {
              roomId,
              code: editor.getValue(),
              language: currentLanguage,
              userId,
              username,
              cursorPosition: position
            });
          }
          
          // Update all remote cursor positions after content change
          setTimeout(() => {
            updateAllRemoteCursorPositions();
            isLocalTyping = false;
          }, 100);
        });

        editor.onDidChangeCursorPosition(() => {
          if (socket) {
            const position = editor.getPosition();
            console.log('Sending cursor position:', position);
            socket.emit('cursor_move', {
              roomId,
              userId,
              username,
              cursorPosition: position
            });
          }
        });

        // Send periodic cursor updates to ensure sync
        setInterval(() => {
          if (socket && editor) {
            const position = editor.getPosition();
            socket.emit('cursor_move', {
              roomId,
              userId,
              username,
              cursorPosition: position
            });
          }
        }, 5000); // Every 5 seconds

        // Listen for scroll events to update cursor positions
        editor.onDidScrollChange(() => {
          setTimeout(() => {
            updateAllRemoteCursorPositions();
          }, 10);
        });

        // Alternative Tab key handling using onKeyDown event
        editor.onKeyDown((e) => {
          if (e.keyCode === monaco.KeyCode.Tab) {
            console.log('Tab key detected via onKeyDown');
            const suggestController = editor.getContribution('editor.contrib.suggestController');
            
            if (suggestController && 
                suggestController.widget && 
                suggestController.widget.value && 
                suggestController.widget.value.state === 1) {
              
              console.log('Preventing default Tab and accepting suggestion');
              e.preventDefault();
              e.stopPropagation();
              suggestController.acceptSelectedSuggestion(false, true);
            }
          }
        });

        // Show autocomplete hint when editor is focused
        editor.onDidFocusEditorText(() => {
          const hint = document.getElementById('autocomplete-hint');
          if (hint) {
            hint.classList.add('show');
            setTimeout(() => {
              hint.classList.remove('show');
            }, 3000); // Hide after 3 seconds
          }
        });

        showNotification('Monaco Editor loaded with AI Autocomplete', 'success');
        
        // Initialize edit permission buttons after editor is loaded
        updateEditButtons();
      } catch (e) {
        console.error('Monaco initialization failed:', e);
        monacoContainer.style.display = 'none';
        showNotification('Monaco Editor failed to load, using fallback editor.', 'error');
        // Optionally, initialize CodeMirror fallback here
      }
    }, function (err) {
      console.error('Monaco require failed:', err);
      monacoContainer.style.display = 'none';
      showNotification('Monaco Editor failed to load, using fallback editor.', 'error');
      // Optionally, initialize CodeMirror fallback here
    });
  } else {
    console.error('Monaco AMD loader not available');
    monacoContainer.style.display = 'none';
    showNotification('Monaco Editor loader not available, using fallback editor.', 'warning');
    // Optionally, initialize CodeMirror fallback here
  }
}

    // Helper function to map language names
    function mapLanguage(language) {
      const map = {
        'js': 'javascript',
        'javascript': 'javascript',
        'ts': 'typescript',
        'typescript': 'typescript',
        'py': 'python',
        'python': 'python',
        'java': 'java',
        'c#': 'csharp',
        'csharp': 'csharp',
        'c++': 'cpp',
        'cpp': 'cpp',
        'php': 'php',
        'rb': 'ruby',
        'ruby': 'ruby',
        'go': 'go',
        'rust': 'rust',
        'html': 'html',
        'css': 'css',
        'sql': 'sql'
      };

      return map[language.toLowerCase()] || 'plaintext';
    }

    // Update remote cursor
    function updateRemoteCursor(remoteUserId, remoteUsername, position, color) {
      if (!position) {
        console.warn('No position provided for cursor update');
        return;
      }
      if (!editor) {
        console.warn('Editor not available for cursor update');
        return;
      }

      console.log('Updating cursor for:', remoteUsername, 'at position:', position);

      // If cursor doesn't exist, create it
      if (!remoteCursors[remoteUserId]) {
        console.log('Creating new cursor for:', remoteUsername);
        
        // Create cursor element
        const cursorDiv = document.createElement('div');
        cursorDiv.className = `remote-cursor cursor-${remoteUserId}`;
        cursorDiv.style.position = 'absolute';
        cursorDiv.style.zIndex = '1000';
        cursorDiv.style.pointerEvents = 'none';

        // Create cursor caret
        const caretDiv = document.createElement('div');
        caretDiv.className = 'cursor-caret';
        caretDiv.style.backgroundColor = color || getRandomColor(remoteUserId);
        caretDiv.style.width = '2px';
        caretDiv.style.height = '18px';

        // Create cursor label
        const labelDiv = document.createElement('div');
        labelDiv.className = 'cursor-label';
        labelDiv.textContent = remoteUsername;
        labelDiv.style.backgroundColor = color || getRandomColor(remoteUserId);
        labelDiv.style.color = 'white';
        labelDiv.style.padding = '2px 6px';
        labelDiv.style.borderRadius = '4px';
        labelDiv.style.fontSize = '11px';
        labelDiv.style.whiteSpace = 'nowrap';
        labelDiv.style.position = 'absolute';
        labelDiv.style.transform = 'translateY(-100%)';
        labelDiv.style.marginTop = '-2px';

        // Append elements
        cursorDiv.appendChild(caretDiv);
        cursorDiv.appendChild(labelDiv);
        
        // Find the Monaco editor container
        const editorContainer = document.querySelector('.monaco-editor');
        if (editorContainer) {
          editorContainer.appendChild(cursorDiv);
          console.log('Cursor appended to Monaco editor container');
        } else {
          console.error('Could not find Monaco editor container');
          return;
        }

        // Store cursor reference
        remoteCursors[remoteUserId] = {
          element: cursorDiv,
          username: remoteUsername,
          color: color || getRandomColor(remoteUserId),
          lastPosition: position
        };
      } else {
        console.log('Updating existing cursor for:', remoteUsername);
        // Update existing cursor's position
        remoteCursors[remoteUserId].lastPosition = position;
      }

      // Position the cursor immediately
      positionCursor(remoteUserId, position);
    }

    // Position cursor at specific coordinates
    function positionCursor(userId, position) {
      if (!remoteCursors[userId] || !position || !editor) {
        console.warn('Cannot position cursor - missing requirements');
        return;
      }

      const cursor = remoteCursors[userId].element;
      
      try {
        // Ensure position has the correct format
        const cursorPosition = {
          lineNumber: Math.max(1, position.lineNumber || 1),
          column: Math.max(1, position.column || 1)
        };

        console.log('Positioning cursor at:', cursorPosition);

        // Get the coordinates of the position in the editor
        const coordinates = editor.getScrolledVisiblePosition(cursorPosition);
        console.log('Got coordinates:', coordinates);

        if (coordinates && typeof coordinates.left === 'number' && typeof coordinates.top === 'number') {
          // Get editor container position
          const editorContainer = document.querySelector('.monaco-editor');
          if (editorContainer) {
            const containerRect = editorContainer.getBoundingClientRect();
            
            // Position relative to the editor container
            cursor.style.left = `${coordinates.left}px`;
            cursor.style.top = `${coordinates.top}px`;
            cursor.style.display = 'block';
            cursor.style.visibility = 'visible';

            console.log('Cursor positioned at:', cursor.style.left, cursor.style.top);

            // Update caret height to match line height
            const lineHeight = editor.getOption(monaco.editor.EditorOption.lineHeight) || 18;
            const caret = cursor.querySelector('.cursor-caret');
            if (caret) {
              caret.style.height = `${lineHeight}px`;
            }

            // Make sure the label is visible and positioned correctly
            const label = cursor.querySelector('.cursor-label');
            if (label) {
              label.style.visibility = 'visible';
            }
          } else {
            console.error('Monaco editor container not found');
          }
        } else {
          // Hide cursor if position is not visible in current viewport
          console.log('Coordinates not available, hiding cursor');
          cursor.style.display = 'none';
        }
      } catch (error) {
        console.error('Error positioning cursor:', error);
        cursor.style.display = 'none';
      }
    }

    // Update all remote cursor positions
    function updateAllRemoteCursorPositions() {
      if (!editor) return;
      
      Object.keys(remoteCursors).forEach(userId => {
        const cursor = remoteCursors[userId];
        if (cursor && cursor.lastPosition) {
          positionCursor(userId, cursor.lastPosition);
        }
      });
    }

    // Debug function for cursor positioning
    function debugCursorPosition(userId, position) {
      console.log(`Positioning cursor for user ${userId}:`, {
        position,
        editorExists: !!editor,
        cursorExists: !!remoteCursors[userId],
        viewportDimensions: editor ? {
          width: editor.getLayoutInfo().width,
          height: editor.getLayoutInfo().height
        } : null
      });
    }

    // Remove remote cursor
    function removeRemoteCursor(userId) {
      if (remoteCursors[userId]) {
        remoteCursors[userId].element.remove();
        delete remoteCursors[userId];
      }
    }

    // Edit Permission Functions
    function updateEditButtons() {
      const requestEditBtn = document.getElementById('request-edit-btn');
      const doneEditingBtn = document.getElementById('done-editing-btn');
      const editorIndicator = document.getElementById('current-editor-indicator');
      const editorNameSpan = document.getElementById('current-editor-name');
      
      if (isCurrentEditor) {
        requestEditBtn.style.display = 'none';
        doneEditingBtn.style.display = 'inline-block';
        
        // Show editor indicator
        if (editorIndicator && editorNameSpan) {
          editorNameSpan.textContent = 'You';
          editorIndicator.style.display = 'inline-block';
        }
      } else if (isOwner) {
        requestEditBtn.style.display = 'none';
        doneEditingBtn.style.display = 'none';
        
        // Show who is currently editing (if not the owner)
        if (editorIndicator && editorNameSpan && currentEditor && currentEditor !== userId) {
          editorNameSpan.textContent = 'Someone';
          editorIndicator.style.display = 'inline-block';
        } else if (editorIndicator) {
          editorIndicator.style.display = 'none';
        }
      } else {
        requestEditBtn.style.display = 'inline-block';
        doneEditingBtn.style.display = 'none';
        
        // Show who is currently editing
        if (editorIndicator && editorNameSpan && currentEditor) {
          editorNameSpan.textContent = currentEditor === userId ? 'You' : 'Someone';
          editorIndicator.style.display = 'inline-block';
        } else if (editorIndicator) {
          editorIndicator.style.display = 'none';
        }
      }
      
      // Update Monaco Editor readonly state
      if (editor && editor.updateOptions) {
        editor.updateOptions({ readOnly: !isCurrentEditor });
      }
    }

    function requestEditAccess() {
      if (socket) {
        socket.emit('request_edit_permission', {
          roomId: roomId,
          userId: userId,
          username: username
        });
      }
    }

    function doneEditing() {
      if (socket && isCurrentEditor) {
        socket.emit('release_edit_permission', {
          roomId: roomId,
          userId: userId
        });
      }
    }

    // Debug function to manually sync cursors
    function forceCursorSync() {
      if (socket) {
        console.log('Forcing cursor sync...');
        socket.emit('request_cursor_positions', { roomId });
      }
    }

    // Make debug functions available globally for testing
    window.forceCursorSync = forceCursorSync;
    window.remoteCursors = remoteCursors;

    // Get random color for cursor based on userId
    function getRandomColor(userId) {
      // Create a consistent color based on the userId
      let hash = 0;
      for (let i = 0; i < userId.length; i++) {
        hash = userId.charCodeAt(i) + ((hash << 5) - hash);
      }

      const colors = [
        '#FF5252', '#FF4081', '#E040FB', '#7C4DFF',
        '#536DFE', '#448AFF', '#40C4FF', '#18FFFF',
        '#64FFDA', '#69F0AE', '#B2FF59', '#EEFF41',
        '#FFFF00', '#FFD740', '#FFAB40', '#FF6E40'
      ];

      return colors[Math.abs(hash) % colors.length];
    }

    // Add participant to the list
    // Add participant to the list
    function addParticipant(userId, username, picture, color) {
      console.log('Adding participant:', userId, username);
      
      // Add to participants modal
      const participantsGrid = document.getElementById('participants-grid');
      if (participantsGrid && !document.getElementById(`participant-card-${userId}`)) {
        const userColor = color || getRandomColor(userId);
        
        const participantCard = document.createElement('div');
        participantCard.className = 'participant-card';
        participantCard.id = `participant-card-${userId}`;
        
        participantCard.innerHTML = `
          <img src="${picture || `https://ui-avatars.com/api/?name=${username}`}" alt="${username}" class="participant-card-avatar">
          <div class="participant-info">
            <div class="participant-card-name">${username}</div>
            <div class="participant-status">
              <div class="status-indicator"></div>
              Online
            </div>
          </div>
        `;
        
        participantsGrid.appendChild(participantCard);
        console.log('Participant added to modal:', username);
      }

      // Update the count in both footer and modal
      const totalParticipants = document.querySelectorAll('.participant-card').length;
      const onlineCountEl = document.getElementById('online-count');
      const participantsCountEl = document.getElementById('participants-count');
      
      if (onlineCountEl) onlineCountEl.textContent = totalParticipants;
      if (participantsCountEl) participantsCountEl.textContent = totalParticipants;
      
      console.log('Updated participant count:', totalParticipants);
    }

    // Remove participant from the list
    function removeParticipant(userId) {
      console.log('Removing participant:', userId);
      
      // Remove from participants modal
      const participantCard = document.getElementById(`participant-card-${userId}`);
      if (participantCard) {
        participantCard.remove();
        console.log('Participant removed from modal:', userId);
      } else {
        console.log('Participant not found for removal:', userId);
      }

      // Update the count in both footer and modal
      const totalParticipants = document.querySelectorAll('.participant-card').length;
      const onlineCountEl = document.getElementById('online-count');
      const participantsCountEl = document.getElementById('participants-count');
      
      if (onlineCountEl) onlineCountEl.textContent = totalParticipants;
      if (participantsCountEl) participantsCountEl.textContent = totalParticipants;
      
      console.log('Updated participant count after removal:', totalParticipants);
    }

    // Add remote user avatar
    function addRemoteAvatar(remoteUserId, remoteUsername, remotePicture) {
      if (document.getElementById(`avatar-${remoteUserId}`)) return;

      const avatarDiv = document.createElement('div');
      avatarDiv.className = 'avatar';
      avatarDiv.id = `avatar-${remoteUserId}`;
      avatarDiv.innerHTML = `
        <img src="${remotePicture || `https://ui-avatars.com/api/?name=${remoteUsername}`}" alt="${remoteUsername}">
        <div class="online-indicator"></div>
      `;

      document.getElementById('remote-avatars').appendChild(avatarDiv);
    }

    // Remove remote user avatar
    function removeRemoteAvatar(remoteUserId) {
      const avatar = document.getElementById(`avatar-${remoteUserId}`);
      if (avatar) {
        avatar.remove();
      }
    }

    // Add message to chat
    function addChatMessage(data, isOwnMessage) {
      const { username, message, timestamp, picture } = data;
      const time = new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${isOwnMessage ? 'outgoing' : 'incoming'} mb-2`;

      messageDiv.innerHTML = `
        ${!isOwnMessage ? `<div class="message-sender">${username}</div>` : ''}
        <div class="message-content">${message}</div>
        <div class="message-time">${time}</div>
      `;

      const chatMessages = document.getElementById('chat-messages');
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Add system message to chat
    function addSystemMessage(message) {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'text-center my-2';
      messageDiv.innerHTML = `<small class="text-muted">${message}</small>`;

      const chatMessages = document.getElementById('chat-messages');
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Display code execution result
    function displayCodeResult(data) {
      const { result, error, language, username, fileName, executionTime } = data;
      const terminal = document.getElementById('terminal');
      
      // Open footer terminal automatically if not open
      const footerTerminal = document.getElementById('footer-terminal');
      const terminalBtn = document.getElementById('footer-terminal-btn');
      if (footerTerminal && !footerTerminal.classList.contains('open')) {
        footerTerminal.classList.add('open');
        if (terminalBtn) terminalBtn.classList.add('active');
      }
      
      if (terminal) {
        const inputDiv = terminal.querySelector('.terminal-input');

        // Remove the terminal input temporarily
        if (inputDiv) {
          inputDiv.remove();
        }

        // Add execution header with language and timing info
        const timestamp = new Date().toLocaleTimeString();
        terminal.innerHTML += `\n<span style="color: #4a9eff;">> [${timestamp}] Running ${language} code${fileName ? ` (${fileName})` : ''}${executionTime ? ` - ${executionTime}` : ''}</span>`;
        
        if (error) {
          terminal.innerHTML += `\n<span style="color: #ff5252;">âŒ Error: ${error}</span>`;
          // Show notification for error
          showNotification(`Code execution failed: ${error}`, 'error', 5000);
        } else if (result) {
          // Format output with proper styling
          const formattedResult = result.split('\n').map(line => 
            line.trim() ? `   ${line}` : ''
          ).join('\n');
          terminal.innerHTML += `\n<span style="color: #4ade80;"> Output:</span>\n<span style="color: #e5e7eb;">${formattedResult}</span>`;
          terminal.innerHTML += `\n<span style="color: #4a9eff;"> Execution completed successfully!</span>`;
          
          // Show success notification
          showNotification(`${language} code executed successfully!`, 'success', 3000);
        } else {
          terminal.innerHTML += `\n<span style="color: #fbbf24;">âš ï¸ No output generated</span>`;
          showNotification(`${language} code executed with no output`, 'warning', 3000);
        }
        }

        // Add separator line
        if (terminal) {
          terminal.innerHTML += `\n<span style="color: #6b7280;">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>`;

          // Add back the terminal input
          terminal.innerHTML += `<div class="terminal-input">
            <span class="terminal-input-prompt">$</span>
            <input type="text" class="terminal-input-field" id="terminal-input" placeholder="Enter bash command...">
          </div>`;

          // Reattach event listener to new terminal input
          const terminalInput = document.getElementById('terminal-input');
          if (terminalInput) {
            terminalInput.addEventListener('keydown', handleTerminalInput);
          }

          // Scroll to bottom
          terminal.scrollTop = terminal.scrollHeight;
        }
      
      // Also update terminal sidebar if it exists
      const terminalOutput = document.getElementById('terminal-output');
      if (terminalOutput) {
        const timestamp = new Date().toLocaleTimeString();
        const headerLine = document.createElement('div');
        headerLine.className = 'terminal-line';
        headerLine.style.color = '#4a9eff';
        headerLine.textContent = `[${timestamp}] Running ${language} code${executionTime ? ` - ${executionTime}` : ''}`;
        terminalOutput.appendChild(headerLine);        if (error) {
          const errorLine = document.createElement('div');
          errorLine.className = 'terminal-line';
          errorLine.style.color = '#ff5252';
          errorLine.textContent = `âŒ Error: ${error}`;
          terminalOutput.appendChild(errorLine);
        } else if (result) {
          const outputLine = document.createElement('div');
          outputLine.className = 'terminal-line';
          outputLine.style.color = '#4ade80';
          outputLine.textContent = 'âœ… Output:';
          terminalOutput.appendChild(outputLine);
          
          result.split('\n').forEach(line => {
            if (line.trim()) {
              const resultLine = document.createElement('div');
              resultLine.className = 'terminal-line';
              resultLine.style.color = '#e5e7eb';
              resultLine.textContent = `   ${line}`;
              terminalOutput.appendChild(resultLine);
            }
          });
          
          const successLine = document.createElement('div');
          successLine.className = 'terminal-line';
          successLine.style.color = '#4a9eff';
          successLine.textContent = ' Execution completed successfully!';
          terminalOutput.appendChild(successLine);
        } else {
          const noOutputLine = document.createElement('div');
          noOutputLine.className = 'terminal-line';
          noOutputLine.style.color = '#fbbf24';
          noOutputLine.textContent = 'âš ï¸ No output generated';
          terminalOutput.appendChild(noOutputLine);
        }
        
        // Add separator
        const separatorLine = document.createElement('div');
        separatorLine.className = 'terminal-line';
        separatorLine.style.color = '#6b7280';
        separatorLine.textContent = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
        terminalOutput.appendChild(separatorLine);
        
        // Scroll to bottom
        terminalOutput.scrollTop = terminalOutput.scrollHeight;
      }
    }

    // Switch file in editor
    function switchFile(fileIndex) {
      const file = files[fileIndex];

      if (file) {
        currentFileIndex = fileIndex;

        // Update editor content and language
        if (editor) {
          editor.setValue(file.content);

          // Check if it's a CodeMirror instance
          if (editor._instance && editor._instance.setOption) {
            // Map file type to CodeMirror mode
            const modeMap = {
              'js': 'javascript',
              'javascript': 'javascript',
              'py': 'python',
              'python': 'python',
              'html': 'htmlmixed',
              'css': 'css',
              'java': 'text/x-java',
              'cpp': 'text/x-c++src',
              'c': 'text/x-csrc',
              'csharp': 'text/x-csharp',
              'php': 'php',
              'ruby': 'ruby',
              'go': 'go',
              'sql': 'sql'
            };
            const mode = modeMap[file.type.toLowerCase()] || 'javascript';
            editor._instance.setOption('mode', mode);
          }
          // Only set language if monaco is available
          else if (typeof monaco !== 'undefined') {
            try {
              monaco.editor.setModelLanguage(editor.getModel(), mapLanguage(file.type));
              // Apply dark theme
              monaco.editor.setTheme('vs-dark');
            } catch (e) {
              console.log('Monaco language setting failed:', e);
            }
          }
        } else {
          // Update fallback editor if the main editor isn't available
          const fallbackEditor = document.getElementById('fallback-editor');
          if (fallbackEditor) {
            fallbackEditor.value = file.content;
          }
        }

        // Update file list selection
        document.querySelectorAll('#files-list li').forEach((li, idx) => {
          if (parseInt(li.getAttribute('data-file-index')) === fileIndex) {
            li.classList.add('active');
          } else {
            li.classList.remove('active');
          }
        });

        // Update language dropdown to match file type
        const languageName = file.type.charAt(0).toUpperCase() + file.type.slice(1);
        document.getElementById('selected-language').textContent = languageName;
        currentLanguage = file.type;

        // Emit event to notify other users
        if (socket) {
          socket.emit('switch_file', {
            roomId,
            userId,
            username,
            fileIndex
          });
        }
      }
    }

    // Document ready
    document.addEventListener('DOMContentLoaded', function() {
      console.log('ENHANCED ROOM LAYOUT DOM LOADED - <%= new Date().toISOString() %>');

      // Make sure editor container is visible with proper dimensions
      const editorContainer = document.querySelector('.monaco-editor-container');
      if (editorContainer) {
        editorContainer.style.height = '100%';
        editorContainer.style.minHeight = '300px';
        editorContainer.style.overflow = 'hidden';
        editorContainer.style.display = 'flex';
        console.log('Editor container dimensions:',
          editorContainer.offsetWidth + 'x' + editorContainer.offsetHeight);
      }

      // Show a loading notification
      showNotification('Loading editor...', 'info');

      // Debug: Check if footer buttons exist
      console.log('Checking footer buttons existence:');
      console.log('Chat button:', document.getElementById('footer-chat-btn'));
      console.log('Participants button:', document.getElementById('footer-participants-btn'));
      console.log('Settings button:', document.getElementById('footer-settings-btn'));
      console.log('Chat sidebar:', document.getElementById('chat-sidebar'));
      console.log('Participants modal:', document.getElementById('participants-modal'));
      console.log('Settings modal:', document.getElementById('settings-modal'));

      // Add a small delay before initializing to ensure DOM is ready
      setTimeout(function() {
        // Initialize editor
        initializeEditor();
      }, 500);

      // Initialize Socket.IO connection
      initializeSocket();

      // Setup UI event handlers
      console.log('About to setup event handlers...');
      console.log('Verifying DOM elements exist:');
      console.log('Footer chat button:', document.getElementById('footer-chat-btn'));
      console.log('Footer participants button:', document.getElementById('footer-participants-btn'));
      console.log('Footer settings button:', document.getElementById('footer-settings-btn'));
      console.log('Footer terminal button:', document.getElementById('footer-terminal-btn'));
      console.log('Add file button:', document.getElementById('add-file'));
      console.log('Save file button:', document.getElementById('save-file'));
      console.log('Close file button:', document.getElementById('close-file'));
      console.log('Chat input:', document.getElementById('chat-input'));
      console.log('Send message button:', document.getElementById('send-message'));
      console.log('Copy link button:', document.getElementById('copy-link'));
      console.log('Run code button:', document.getElementById('run-code'));
      console.log('Leave room button:', document.getElementById('leave-room'));
      console.log('Terminal input:', document.getElementById('terminal-input'));
      console.log('Terminal sidebar input:', document.getElementById('terminal-input-sidebar'));
      setupEventHandlers();
      console.log('Event handlers setup completed');

      // Initialize voice chat functionality
      setupVoiceChatEventListeners();
      initializeVoiceChatSocket();
      updateVoiceChatUI();
      console.log('Voice chat initialized');

      // Toggle dark/light mode
      setupThemeToggle();

      // Apply performance mode if set
      if (performanceMode) {
        document.body.classList.add('performance-mode');
        document.querySelector('.spline-container').style.display = 'none';
        document.querySelector('.gradient-bg').style.opacity = '1';
        document.querySelector('.gradient-bg').style.zIndex = '-1';

        // Show notification
        showNotification('Performance mode enabled', 'info');
      }
    });

    // Professional notification system
    function showNotification(message, type = 'info', duration = 4000, title = null) {
      const container = document.getElementById('notification-container');
      if (!container) return;

      // Create notification element
      const notification = document.createElement('div');
      notification.className = `notification-item ${type}`;
      
      // Generate unique ID for this notification
      const notificationId = 'notif_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      notification.id = notificationId;

      // Get appropriate icon based on type
      const icons = {
        success: 'âœ“',
        error: 'âœ•',
        warning: 'âš ',
        info: 'i'
      };

      // Auto-generate title if not provided
      const titles = {
        success: 'Success',
        error: 'Error',
        warning: 'Warning',
        info: 'Info'
      };

      const finalTitle = title || titles[type] || 'Notification';
      const icon = icons[type] || 'i';

      notification.innerHTML = `
        <div class="notification-icon">${icon}</div>
        <div class="notification-content">
          <div class="notification-title">${finalTitle}</div>
          <div class="notification-message">${message}</div>
        </div>
        <button class="notification-close" aria-label="Close notification">
          <i class="fas fa-times"></i>
        </button>
        <div class="notification-progress"></div>
      `;

      // Add to container
      container.appendChild(notification);

      // Show animation
      setTimeout(() => {
        notification.classList.add('show');
      }, 10);

      // Set up close button
      const closeBtn = notification.querySelector('.notification-close');
      closeBtn.addEventListener('click', () => {
        removeNotification(notification);
      });

      // Auto-remove after duration
      const autoRemoveTimer = setTimeout(() => {
        removeNotification(notification);
      }, duration);

      // Store timer reference for potential cancellation
      notification.autoRemoveTimer = autoRemoveTimer;

      return notificationId;
    }

    // Remove notification with animation
    function removeNotification(notification) {
      if (!notification || !notification.parentNode) return;
      
      // Cancel auto-remove timer if it exists
      if (notification.autoRemoveTimer) {
        clearTimeout(notification.autoRemoveTimer);
      }

      notification.classList.add('fade-out');
      
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 400);
    }

    // Clear all notifications
    function clearAllNotifications() {
      const container = document.getElementById('notification-container');
      if (container) {
        const notifications = container.querySelectorAll('.notification-item');
        notifications.forEach(notification => {
          removeNotification(notification);
        });
      }
    }

    // Show Pro upgrade modal for specific features
    function showProUpgradeModal(feature, message) {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.innerHTML = `
        <div class="modal-content pro-upgrade-modal" style="max-width: 500px; text-align: center;">
          <div class="modal-header">
            <h3 style="color: #ff6b35; margin: 0;">ðŸš€ Upgrade to Pro</h3>
          </div>
          <div class="modal-body" style="padding: 20px;">
            <div style="margin-bottom: 20px;">
              <i class="bi bi-mic" style="font-size: 3rem; color: #ff6b35; margin-bottom: 15px;"></i>
            </div>
            <p style="font-size: 1.1rem; margin-bottom: 15px; color: #333;">
              ${message}
            </p>
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <h4 style="color: #333; margin-bottom: 10px;">Pro Features Include:</h4>
              <ul style="text-align: left; list-style: none; padding: 0;">
                <li style="margin: 8px 0;"><i class="bi bi-check-circle-fill" style="color: #28a745;"></i> Voice Chat with team members</li>
                <li style="margin: 8px 0;"><i class="bi bi-check-circle-fill" style="color: #28a745;"></i> AI Code Analysis & Debugging</li>
                <li style="margin: 8px 0;"><i class="bi bi-check-circle-fill" style="color: #28a745;"></i> Unlimited room capacity (50 users)</li>
                <li style="margin: 8px 0;"><i class="bi bi-check-circle-fill" style="color: #28a745;"></i> Priority customer support</li>
                <li style="margin: 8px 0;"><i class="bi bi-check-circle-fill" style="color: #28a745;"></i> Advanced collaboration tools</li>
              </ul>
            </div>
            <div style="margin: 20px 0;">
              <span style="font-size: 1.5rem; font-weight: bold; color: #ff6b35;">Only â‚¹99 for 3 months</span>
            </div>
          </div>
          <div class="modal-footer" style="text-align: center; padding: 20px;">
            <button class="btn btn-primary" onclick="upgradeToProNow()" style="background: linear-gradient(135deg, #ff6b35, #f7931e); border: none; padding: 12px 30px; font-size: 1.1rem; margin-right: 10px;">
              Upgrade Now ðŸš€
            </button>
            <button class="btn btn-secondary" onclick="closeProUpgradeModal()" style="padding: 12px 20px;">
              Maybe Later
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Add event listener to close modal when clicking outside
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          closeProUpgradeModal();
        }
      });
      
      // Store reference for closing
      window.currentProUpgradeModal = modal;
    }

    // Close pro upgrade modal
    function closeProUpgradeModal() {
      const modal = window.currentProUpgradeModal;
      if (modal && modal.parentNode) {
        modal.remove();
        window.currentProUpgradeModal = null;
      }
    }

    // Redirect to upgrade page
    function upgradeToProNow() {
      closeProUpgradeModal();
      window.open('/payment', '_blank');
    }

    // Setup event handlers for UI elements
    function setupEventHandlers() {
      // Language selection
      document.querySelectorAll('.language-option').forEach(option => {
        option.addEventListener('click', function(e) {
          e.preventDefault();
          const language = this.getAttribute('data-language');
          currentLanguage = language;

          // Update selected language display
          document.getElementById('selected-language').textContent = language;

          // Update editor language
          monaco.editor.setModelLanguage(editor.getModel(), mapLanguage(language));

          // Update current file type
          files[currentFileIndex].type = language;

          // Emit language change event
          if (socket) {
            socket.emit('language_change', {
              roomId,
              language,
              userId,
              username,
              fileIndex: currentFileIndex
            });
          }
        });
      });

      // File selection
      document.querySelectorAll('#files-list li').forEach(li => {
        li.addEventListener('click', function() {
          const fileIndex = parseInt(this.getAttribute('data-file-index'));
          switchFile(fileIndex);
        });
      });

      // Add new file
      const addFileBtn = document.getElementById('add-file');
      if (addFileBtn) {
        addFileBtn.addEventListener('click', function() {
        const fileName = prompt('Enter file name (with extension):');
        if (!fileName) return;

        // Determine file type and content based on extension
        let fileType = 'plaintext';
        let defaultContent = '';
        
        if (fileName.endsWith('.js')) {
          fileType = 'javascript';
          defaultContent = `// ${fileName} - JavaScript file\nconsole.log('Hello from ${fileName}');`;
        } else if (fileName.endsWith('.py')) {
          fileType = 'python';
          defaultContent = `# ${fileName} - Python file\nprint("Hello from ${fileName}")`;
        } else if (fileName.endsWith('.html')) {
          fileType = 'html';
          defaultContent = `<!DOCTYPE html>\n<html>\n<head>\n    <title>${fileName}</title>\n</head>\n<body>\n    <h1>Hello from ${fileName}</h1>\n</body>\n</html>`;
        } else if (fileName.endsWith('.css')) {
          fileType = 'css';
          defaultContent = `/* ${fileName} - CSS file */\nbody {\n    font-family: Arial, sans-serif;\n}`;
        } else if (fileName.endsWith('.java')) {
          fileType = 'java';
          const className = fileName.replace('.java', '');
          defaultContent = `// ${fileName} - Java file\npublic class ${className} {\n    public static void main(String[] args) {\n        System.out.println("Hello from ${fileName}");\n    }\n}`;
        } else if (fileName.endsWith('.cpp') || fileName.endsWith('.c++')) {
          fileType = 'cpp';
          defaultContent = `// ${fileName} - C++ file\n#include <iostream>\nusing namespace std;\n\nint main() {\n    cout << "Hello from ${fileName}" << endl;\n    return 0;\n}`;
        } else if (fileName.endsWith('.c')) {
          fileType = 'c';
          defaultContent = `// ${fileName} - C file\n#include <stdio.h>\n\nint main() {\n    printf("Hello from ${fileName}\\n");\n    return 0;\n}`;
        } else if (fileName.endsWith('.ts')) {
          fileType = 'typescript';
          defaultContent = `// ${fileName} - TypeScript file\nconsole.log('Hello from ${fileName}');`;
        } else if (fileName.endsWith('.go')) {
          fileType = 'go';
          defaultContent = `// ${fileName} - Go file\npackage main\n\nimport "fmt"\n\nfunc main() {\n    fmt.Println("Hello from ${fileName}")\n}`;
        } else if (fileName.endsWith('.rb')) {
          fileType = 'ruby';
          defaultContent = `# ${fileName} - Ruby file\nputs "Hello from ${fileName}"`;
        } else if (fileName.endsWith('.php')) {
          fileType = 'php';
          defaultContent = `<?php\n// ${fileName} - PHP file\necho "Hello from ${fileName}";\n?>`;
        } else if (fileName.endsWith('.sql')) {
          fileType = 'sql';
          defaultContent = `-- ${fileName} - SQL file\nSELECT 'Hello from ${fileName}' AS message;`;
        } else if (fileName.endsWith('.json')) {
          fileType = 'json';
          defaultContent = `{\n  "message": "Hello from ${fileName}"\n}`;
        } else if (fileName.endsWith('.md')) {
          fileType = 'markdown';
          defaultContent = `# ${fileName}\n\nHello from ${fileName}`;
        } else {
          fileType = 'plaintext';
          defaultContent = `# ${fileName}\nCreated by ${username}`;
        }

        // Add file to the files array
        const newFileIndex = files.length;
        files.push({
          name: fileName,
          type: fileType,
          content: defaultContent
        });

        // Add file to the list
        const filesList = document.getElementById('files-list');
        const li = document.createElement('li');
        li.setAttribute('data-file-index', newFileIndex);

        // Determine icon based on file type
        let iconClass = 'far fa-file-code';
        if (fileType === 'javascript') iconClass = 'fab fa-js-square';
        else if (fileType === 'html') iconClass = 'fab fa-html5';
        else if (fileType === 'css') iconClass = 'fab fa-css3-alt';
        else if (fileType === 'python') iconClass = 'fab fa-python';
        else if (fileType === 'java') iconClass = 'fab fa-java';
        else if (fileType === 'php') iconClass = 'fab fa-php';
        else if (fileType === 'go') iconClass = 'fab fa-golang';
        else if (fileType === 'markdown') iconClass = 'fab fa-markdown';

        li.innerHTML = `<i class="file-icon ${iconClass}"></i> ${fileName}`;
        filesList.appendChild(li);

        // Add click event
        li.addEventListener('click', function() {
          const fileIndex = parseInt(this.getAttribute('data-file-index'));
          switchFile(fileIndex);
        });

        // Switch to the new file
        switchFile(newFileIndex);

        // Notify other users
        if (socket) {
          socket.emit('new_file', {
            roomId,
            userId,
            username,
            file: {
              name: fileName,
              type: fileType,
              content: defaultContent,
              index: newFileIndex
            }
          });
        }
      });
      } else {
        console.error('Add file button not found!');
      }

      // Save file functionality
      const saveFileBtn = document.getElementById('save-file');
      if (saveFileBtn) {
        saveFileBtn.addEventListener('click', function() {
        if (!editor || files.length === 0) return;

        // Update current file content
        files[currentFileIndex].content = editor.getValue();
        
        // Show save notification
        showNotification(`${files[currentFileIndex].name} saved successfully!`, 'success');

        // Optionally, you could emit a save event to other users
        if (socket) {
          socket.emit('file_saved', {
            roomId,
            userId,
            username,
            fileName: files[currentFileIndex].name,
            fileIndex: currentFileIndex
          });
        }        });
      } else {
        console.error('Save file button not found!');
      }

      // Close file functionality
      const closeFileBtn = document.getElementById('close-file');
      if (closeFileBtn) {
        closeFileBtn.addEventListener('click', function() {
        if (files.length <= 1) {
          showNotification('Cannot close the last file!', 'warning');
          return;
        }

        if (confirm(`Are you sure you want to close ${files[currentFileIndex].name}?`)) {
          const closedFileName = files[currentFileIndex].name;
          const closedFileIndex = currentFileIndex;

          // Remove from files array
          files.splice(currentFileIndex, 1);

          // Remove from file list UI
          const fileItem = document.querySelector(`[data-file-index="${currentFileIndex}"]`);
          if (fileItem) {
            fileItem.remove();
          }

          // Update all file indices
          document.querySelectorAll('#files-list li').forEach((li, index) => {
            li.setAttribute('data-file-index', index);
          });

          // Switch to previous file or first file
          const newIndex = currentFileIndex > 0 ? currentFileIndex - 1 : 0;
          currentFileIndex = newIndex;
          switchFile(newIndex);

          // Show notification
          showNotification(`${closedFileName} closed successfully!`, 'info');

          // Notify other users
          if (socket) {
            socket.emit('file_closed', {
              roomId,
              userId,
              username,
              fileName: closedFileName,
              fileIndex: closedFileIndex
            });
          }
        }
      });
      } else {
        console.error('Close file button not found!');
      }

      // Chat functionality
      const chatInput = document.getElementById('chat-input');
      const sendButton = document.getElementById('send-message');

      function sendMessage() {
        const message = chatInput.value.trim();
        if (message && socket) {
          socket.emit('send_message', {
            roomId,
            userId,
            username,
            picture: userPicture,
            message,
            timestamp: new Date().toISOString()
          });
          chatInput.value = '';
        }
      }

      if (sendButton) {
        sendButton.addEventListener('click', sendMessage);
      } else {
        console.error('Send message button not found!');
      }
      
      if (chatInput) {
        chatInput.addEventListener('keypress', function(e) {
          if (e.key === 'Enter' || e.key === 'Tab') {
            sendMessage();
          }
        });
      } else {
        console.error('Chat input not found!');
      }

      // Copy room link
      const copyLinkBtn = document.getElementById('copy-link');
      if (copyLinkBtn) {
        copyLinkBtn.addEventListener('click', function() {
        const url = window.location.href;
        navigator.clipboard.writeText(url).then(() => {
          // Show toast notification
          const toast = document.createElement('div');
          toast.className = 'position-fixed bottom-0 end-0 p-3';
          toast.style.zIndex = '5';
          toast.innerHTML = `
            <div class="toast show bg-success text-white" role="alert" aria-live="assertive" aria-atomic="true">
              <div class="toast-header">
                <strong class="me-auto">CodeCollab</strong>
                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
              </div>
              <div class="toast-body">
                Room link copied to clipboard!
              </div>
            </div>
          `;
          document.body.appendChild(toast);

          // Remove after 3 seconds
          setTimeout(() => {
            document.body.removeChild(toast);
          }, 3000);
        });
      });
      } else {
        console.error('Copy link button not found!');
      }

      // Run code
      const runCodeBtn = document.getElementById('run-code');
      if (runCodeBtn) {
        runCodeBtn.addEventListener('click', function() {
          if (socket && editor) {
            const code = editor.getValue().trim();
            
            if (!code) {
              showNotification('Please write some code before running it!', 'warning', 3000);
              return;
            }
            
            // Disable button during execution
            runCodeBtn.disabled = true;
            runCodeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Running...';
            
            // Open footer terminal automatically
            const footerTerminal = document.getElementById('footer-terminal');
            const terminalBtn = document.getElementById('footer-terminal-btn');
            if (footerTerminal && !footerTerminal.classList.contains('open')) {
              footerTerminal.classList.add('open');
              if (terminalBtn) terminalBtn.classList.add('active');
            }
            
            // Clear terminal first
            const terminal = document.getElementById('terminal');
            if (terminal) {
              const inputDiv = terminal.querySelector('.terminal-input');

              // Remove the terminal input temporarily
              if (inputDiv) {
                inputDiv.remove();
              }

              const timestamp = new Date().toLocaleTimeString();
              terminal.innerHTML += `\n<span style="color: #4a9eff;">> [${timestamp}] Starting execution...</span>`;

              // Preserve terminal input
              terminal.innerHTML += `<div class="terminal-input">
                <span class="terminal-input-prompt">$</span>
                <input type="text" class="terminal-input-field" id="terminal-input" placeholder="Enter bash command..." spellcheck="false">
              </div>`;

              // Reattach event listener to new terminal input
              const terminalInput = document.getElementById('terminal-input');
              if (terminalInput) {
                terminalInput.addEventListener('keydown', handleTerminalInput);
              }
            }

            // Show notification
            showNotification(`Executing ${currentLanguage} code...`, 'info', 2000);

            socket.emit('run_code', {
              roomId,
              code: code,
              language: currentLanguage,
              userId,
              username,
              fileName: files[currentFileIndex].name
            });
            
            // Re-enable button after a timeout (in case no response)
            setTimeout(() => {
              runCodeBtn.disabled = false;
              runCodeBtn.innerHTML = '<i class="fas fa-play"></i> Run';
            }, 30000); // 30 second timeout
          } else {
            showNotification('Unable to execute code. Please check your connection.', 'error', 4000);
          }
        });
        
        // Also handle Ctrl+Enter keyboard shortcut for running code
        document.addEventListener('keydown', function(e) {
          if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            e.preventDefault();
            runCodeBtn.click();
          }
        });
      } else {
        console.error('Run code button not found!');
      }

      // Edit Permission Buttons
      const requestEditBtn = document.getElementById('request-edit-btn');
      const doneEditingBtn = document.getElementById('done-editing-btn');
      
      if (requestEditBtn) {
        requestEditBtn.addEventListener('click', function() {
          requestEditAccess();
        });
      }
      
      if (doneEditingBtn) {
        doneEditingBtn.addEventListener('click', function() {
          doneEditing();
        });
      }

      // Terminal input handling
      handleTerminalInput = function(e) {
        if (e.key === 'Enter') {
          const command = e.target.value.trim();
          if (!command) return;

          // Update terminal with command
          const terminal = document.getElementById('terminal');
          terminal.innerHTML = terminal.innerHTML.replace(/<div class="terminal-input">[\s\S]*?<\/div>/, '');
          terminal.innerHTML += `> ${command}\n`;

          // Execute bash command via socket
          if (socket) {
            socket.emit('bash_command', {
              roomId,
              command,
              userId,
              username
            });
          }

          // Add back the terminal input
          terminal.innerHTML += `<div class="terminal-input">
            <span class="terminal-input-prompt">$</span>
            <input type="text" class="terminal-input-field" id="terminal-input" placeholder="Enter bash command...">
          </div>`;

          // Focus on the new input field
          document.getElementById('terminal-input').focus();

          // Reattach event listener
          const terminalInputEl = document.getElementById('terminal-input');
          if (terminalInputEl) {
            terminalInputEl.addEventListener('keydown', handleTerminalInput);
          }
        }
      }

      // Terminal sidebar input handling
      const handleTerminalSidebarInput = function(e) {
        if (e.key === 'Enter') {
          const command = e.target.value.trim();
          if (!command) return;

          // Add command to terminal output
          const terminalOutput = document.getElementById('terminal-output');
          const commandLine = document.createElement('div');
          commandLine.className = 'terminal-line';
          commandLine.textContent = `$ ${command}`;
          terminalOutput.appendChild(commandLine);

          // Clear input
          e.target.value = '';

          // Execute bash command via socket
          if (socket) {
            socket.emit('bash_command', {
              roomId,
              command,
              userId,
              username
            });
          }

          // Scroll to bottom
          terminalOutput.scrollTop = terminalOutput.scrollHeight;
        }
      };

      // Setup terminal sidebar input
      const terminalSidebarInput = document.getElementById('terminal-input-sidebar');
      if (terminalSidebarInput) {
        terminalSidebarInput.addEventListener('keydown', handleTerminalSidebarInput);
        console.log('Terminal sidebar input handler attached');
      } else {
        console.error('Terminal sidebar input not found!');
      }

      // Initial terminal input setup
      const terminalInputEl = document.getElementById('terminal-input');
      if (terminalInputEl) {
        terminalInputEl.addEventListener('keydown', handleTerminalInput);
      } else {
        console.error('Terminal input not found!');
      }

      // Leave room
      const leaveRoomBtn = document.getElementById('leave-room');
      if (leaveRoomBtn) {
        leaveRoomBtn.addEventListener('click', function() {
          if (confirm('Are you sure you want to leave this room?')) {
            window.location.href = '/dashboard';
          }
        });
      } else {
        console.error('Leave room button not found!');
      }

      // Toggle chat panel (legacy - may not exist)
      const collapseChatBtn = document.getElementById('collapse-chat');
      if (collapseChatBtn) {
        collapseChatBtn.addEventListener('click', function() {
          const chatPanel = document.querySelector('.chat-panel');
          const icon = this.querySelector('i');

          if (chatPanel.style.width === '0px') {
            chatPanel.style.width = '300px';
            icon.className = 'fas fa-chevron-right';
          } else {
            chatPanel.style.width = '0px';
            icon.className = 'fas fa-chevron-left';
          }

          // Resize editor after changing layout
          if (editor) {
            editor.layout();
          }
        });
      } else {
        console.error('Collapse chat button not found (may be expected for new layout)!');
      }

      // Footer Button Event Handlers
      
      console.log('Setting up footer button event handlers...');
      
      // Chat button - toggle slide-in chat panel
      const footerChatBtn = document.getElementById('footer-chat-btn');
      if (footerChatBtn) {
        console.log('Footer chat button found, attaching event listener');
        footerChatBtn.addEventListener('click', function() {
          console.log('Chat button clicked');
          const chatSidebar = document.getElementById('chat-sidebar');
          const isOpen = chatSidebar.classList.contains('open');
          
          if (isOpen) {
            chatSidebar.classList.remove('open');
            this.classList.remove('active');
          } else {
            chatSidebar.classList.add('open');
            this.classList.add('active');
            // Focus on chat input when opened
            setTimeout(() => {
              const chatInput = document.getElementById('chat-input');
              if (chatInput) chatInput.focus();
            }, 300);
          }
        });
      } else {
        console.error('Footer chat button not found!');
      }

      // Chat close button
      const chatCloseBtn = document.getElementById('chat-close-btn');
      if (chatCloseBtn) {
        console.log('Chat close button found, attaching event listener');
        chatCloseBtn.addEventListener('click', function() {
          console.log('Chat close button clicked');
          const chatSidebar = document.getElementById('chat-sidebar');
          const chatBtn = document.getElementById('footer-chat-btn');
          chatSidebar.classList.remove('open');
          chatBtn.classList.remove('active');
        });
      } else {
        console.error('Chat close button not found!');
      }

      // AI Chat button - toggle slide-in AI chat panel
      const footerAIChatBtn = document.getElementById('footer-ai-chat-btn');
      if (footerAIChatBtn) {
        console.log('Footer AI chat button found, attaching event listener');
        footerAIChatBtn.addEventListener('click', function() {
          console.log('AI Chat button clicked');
          const aiChatSidebar = document.getElementById('ai-chat-sidebar');
          const isOpen = aiChatSidebar.classList.contains('open');
          
          if (isOpen) {
            aiChatSidebar.classList.remove('open');
            this.classList.remove('active');
          } else {
            // Close regular chat if open
            const chatSidebar = document.getElementById('chat-sidebar');
            const chatBtn = document.getElementById('footer-chat-btn');
            if (chatSidebar.classList.contains('open')) {
              chatSidebar.classList.remove('open');
              chatBtn.classList.remove('active');
            }
            
            aiChatSidebar.classList.add('open');
            this.classList.add('active');
            // Focus on AI chat input when opened
            setTimeout(() => {
              const aiChatInput = document.getElementById('ai-chat-input');
              if (aiChatInput) aiChatInput.focus();
            }, 300);
          }
        });
      } else {
        console.error('Footer AI chat button not found!');
      }

      // AI Chat close button
      const aiChatCloseBtn = document.getElementById('ai-chat-close-btn');
      if (aiChatCloseBtn) {
        console.log('AI Chat close button found, attaching event listener');
        aiChatCloseBtn.addEventListener('click', function() {
          console.log('AI Chat close button clicked');
          const aiChatSidebar = document.getElementById('ai-chat-sidebar');
          const aiChatBtn = document.getElementById('footer-ai-chat-btn');
          aiChatSidebar.classList.remove('open');
          aiChatBtn.classList.remove('active');
        });
      } else {
        console.error('AI Chat close button not found!');
      }

      // Participants button - show modal
      const footerParticipantsBtn = document.getElementById('footer-participants-btn');
      if (footerParticipantsBtn) {
        console.log('Footer participants button found, attaching event listener');
        footerParticipantsBtn.addEventListener('click', function() {
          console.log('Participants button clicked');
          const modal = document.getElementById('participants-modal');
          if (modal) {
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
          } else {
            console.error('Participants modal not found!');
          }
        });
      } else {
        console.error('Footer participants button not found!');
      }

      // Participants modal close buttons
      const participantsCloseBtn = document.getElementById('participants-close-btn');
      if (participantsCloseBtn) {
        console.log('Participants close button found, attaching event listener');
        participantsCloseBtn.addEventListener('click', function() {
          console.log('Participants close button clicked');
          closeModal('participants-modal');
        });
      } else {
        console.error('Participants close button not found!');
      }

      // Settings button - show modal
      const footerSettingsBtn = document.getElementById('footer-settings-btn');
      if (footerSettingsBtn) {
        console.log('Footer settings button found, attaching event listener');
        footerSettingsBtn.addEventListener('click', function() {
          console.log('Settings button clicked');
          const modal = document.getElementById('settings-modal');
          if (modal) {
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
            
            // Load current settings
            loadCurrentSettings();
          } else {
            console.error('Settings modal not found!');
          }
        });
      } else {
        console.error('Footer settings button not found!');
      }

      // Settings modal close button
      const settingsCloseBtn = document.getElementById('settings-close-btn');
      if (settingsCloseBtn) {
        console.log('Settings close button found, attaching event listener');
        settingsCloseBtn.addEventListener('click', function() {
          console.log('Settings close button clicked');
          closeModal('settings-modal');
        });
      } else {
        console.error('Settings close button not found!');
      }

      // Voice Chat Options button - show modal
      const voiceChatOptionsBtn = document.getElementById('voice-chat-options-btn');
      if (voiceChatOptionsBtn) {
        console.log('Voice Chat Options button found, attaching event listener');
        voiceChatOptionsBtn.addEventListener('click', function() {
          console.log('Voice Chat Options button clicked');
          const modal = document.getElementById('voice-chat-options-modal');
          if (modal) {
            updateVoiceParticipantsModal();
            updateVoiceChatOptionsModalControls();
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
          } else {
            console.error('Voice Chat Options modal not found!');
          }
        });
      } else {
        console.log('Voice Chat Options button not found!');
      }

      // Voice Chat Options modal close button
      const voiceChatOptionsCloseBtn = document.getElementById('voice-chat-options-close-btn');
      if (voiceChatOptionsCloseBtn) {
        console.log('Voice Chat Options close button found, attaching event listener');
        voiceChatOptionsCloseBtn.addEventListener('click', function() {
          console.log('Voice Chat Options close button clicked');
          closeModal('voice-chat-options-modal');
        });
      } else {
        console.log('Voice Chat Options close button not found!');
      }

      // Voice Chat Modal Controls
      const modalMuteBtn = document.getElementById('modal-mute-btn');
      if (modalMuteBtn) {
        modalMuteBtn.addEventListener('click', function() {
          if (muteBtn) muteBtn.click();
        });
      }

      const modalDeafenBtn = document.getElementById('modal-deafen-btn');
      if (modalDeafenBtn) {
        modalDeafenBtn.addEventListener('click', function() {
          if (deafenBtn) deafenBtn.click();
        });
      }

      const modalLeaveVoiceBtn = document.getElementById('modal-leave-voice-btn');
      if (modalLeaveVoiceBtn) {
        modalLeaveVoiceBtn.addEventListener('click', function() {
          if (leaveVoiceBtn) leaveVoiceBtn.click();
          closeModal('voice-chat-options-modal');
        });
      }

      // Terminal button - toggle footer terminal panel
      const footerTerminalBtn = document.getElementById('footer-terminal-btn');
      if (footerTerminalBtn) {
        console.log('Footer terminal button found, attaching event listener');
        footerTerminalBtn.addEventListener('click', function() {
          console.log('Terminal button clicked');
          const footerTerminal = document.getElementById('footer-terminal');
          const isOpen = footerTerminal.classList.contains('open');
          
          if (isOpen) {
            footerTerminal.classList.remove('open');
            this.classList.remove('active');
          } else {
            footerTerminal.classList.add('open');
            this.classList.add('active');
            // Focus on terminal input when opened
            setTimeout(() => {
              const terminalInput = document.getElementById('terminal-input');
              if (terminalInput) terminalInput.focus();
            }, 300);
          }
        });
      } else {
        console.error('Footer terminal button not found!');
      }

      // Footer terminal close button
      const footerTerminalClose = document.getElementById('footer-terminal-close');
      if (footerTerminalClose) {
        footerTerminalClose.addEventListener('click', function() {
          const footerTerminal = document.getElementById('footer-terminal');
          const terminalBtn = document.getElementById('footer-terminal-btn');
          footerTerminal.classList.remove('open');
          if (terminalBtn) terminalBtn.classList.remove('active');
        });
      }

      // Terminal close button
      const terminalCloseBtn = document.getElementById('terminal-close-btn');
      if (terminalCloseBtn) {
        console.log('Terminal close button found, attaching event listener');
        terminalCloseBtn.addEventListener('click', function() {
          console.log('Terminal close button clicked');
          const terminalSidebar = document.getElementById('terminal-sidebar');
          const terminalBtn = document.getElementById('footer-terminal-btn');
          terminalSidebar.classList.remove('open');
          terminalBtn.classList.remove('active');
        });
      } else {
        console.error('Terminal close button not found!');
      }

      // Close modals when clicking outside
      const modals = document.querySelectorAll('.modal-overlay');
      console.log('Found modals:', modals.length);
      modals.forEach((modal, index) => {
        console.log(`Setting up modal ${index} (${modal.id}) click-outside handler`);
        modal.addEventListener('click', function(e) {
          if (e.target === this) {
            console.log(`Closing modal ${this.id} by clicking outside`);
            closeModal(this.id);
          }
        });
      });

      // Settings Event Handlers
      console.log('Setting up settings event handlers...');
      
      // Show/Hide Remote Cursors
      const settingShowCursors = document.getElementById('setting-show-cursors');
      if (settingShowCursors) {
        settingShowCursors.addEventListener('change', function() {
          const showCursors = this.checked;
          Object.keys(remoteCursors).forEach(userId => {
            const cursor = remoteCursors[userId].element;
            cursor.style.display = showCursors ? 'block' : 'none';
          });
          localStorage.setItem('codecollab-show-cursors', showCursors);
          showNotification(`Remote cursors ${showCursors ? 'enabled' : 'disabled'}`, 'info');
        });
      } else {
        console.error('setting-show-cursors element not found');
      }

      // Auto Save
      const settingAutoSave = document.getElementById('setting-auto-save');
      if (settingAutoSave) {
        settingAutoSave.addEventListener('change', function() {
          const autoSave = this.checked;
          localStorage.setItem('codecollab-auto-save', autoSave);
          showNotification(`Auto save ${autoSave ? 'enabled' : 'disabled'}`, 'info');
          
          if (autoSave && !window.autoSaveInterval) {
            // Set up auto save every 30 seconds
            window.autoSaveInterval = setInterval(() => {
              if (editor && files.length > 0) {
                files[currentFileIndex].content = editor.getValue();
                showNotification('Auto saved', 'success', 1000);
              }
            }, 30000);
          } else if (!autoSave && window.autoSaveInterval) {
            clearInterval(window.autoSaveInterval);
            window.autoSaveInterval = null;
          }
        });
      } else {
        console.error('setting-auto-save element not found');
      }

      // Line Numbers
      document.getElementById('setting-line-numbers').addEventListener('change', function() {
        const showLineNumbers = this.checked;
        if (editor && typeof monaco !== 'undefined') {
          editor.updateOptions({ lineNumbers: showLineNumbers ? 'on' : 'off' });
        }
        localStorage.setItem('codecollab-line-numbers', showLineNumbers);
        showNotification(`Line numbers ${showLineNumbers ? 'enabled' : 'disabled'}`, 'info');
      });

      // Minimap
      document.getElementById('setting-minimap').addEventListener('change', function() {
        const showMinimap = this.checked;
        if (editor && typeof monaco !== 'undefined') {
          editor.updateOptions({ minimap: { enabled: showMinimap } });
        }
        localStorage.setItem('codecollab-minimap', showMinimap);
        showNotification(`Minimap ${showMinimap ? 'enabled' : 'disabled'}`, 'info');
      });

      // Real-time Sync
      document.getElementById('setting-realtime-sync').addEventListener('change', function() {
        const realtimeSync = this.checked;
        localStorage.setItem('codecollab-realtime-sync', realtimeSync);
        showNotification(`Real-time sync ${realtimeSync ? 'enabled' : 'disabled'}`, 'info');
        
        // You can add logic here to enable/disable real-time synchronization
        window.realtimeSyncEnabled = realtimeSync;
      });

      // Chat Notifications
      document.getElementById('setting-chat-notifications').addEventListener('change', function() {
        const chatNotifications = this.checked;
        localStorage.setItem('codecollab-chat-notifications', chatNotifications);
        showNotification(`Chat notifications ${chatNotifications ? 'enabled' : 'disabled'}`, 'info');
        window.chatNotificationsEnabled = chatNotifications;
      });

      // Join/Leave Alerts
      document.getElementById('setting-join-alerts').addEventListener('change', function() {
        const joinAlerts = this.checked;
        localStorage.setItem('codecollab-join-alerts', joinAlerts);
        showNotification(`Join/leave alerts ${joinAlerts ? 'enabled' : 'disabled'}`, 'info');
        window.joinAlertsEnabled = joinAlerts;
      });

      // Performance Mode
      document.getElementById('setting-performance-mode').addEventListener('change', function() {
        const performanceMode = this.checked;
        localStorage.setItem('codecollab-performance-mode', performanceMode);
        
        if (performanceMode) {
          document.body.classList.add('performance-mode');
          document.querySelector('.spline-container').style.display = 'none';
          document.querySelector('.gradient-bg').style.opacity = '1';
          document.querySelector('.gradient-bg').style.zIndex = '-1';
          showNotification('Performance mode enabled', 'success');
        } else {
          document.body.classList.remove('performance-mode');
          document.querySelector('.spline-container').style.display = 'block';
          document.querySelector('.gradient-bg').style.opacity = '0.3';
          document.querySelector('.gradient-bg').style.zIndex = '-2';
          showNotification('Performance mode disabled', 'info');
        }
      });

      // Auto Complete
      document.getElementById('setting-auto-complete').addEventListener('change', function() {
        const autoComplete = this.checked;
        if (editor && typeof monaco !== 'undefined') {
          editor.updateOptions({ 
            suggestOnTriggerCharacters: autoComplete,
            quickSuggestions: autoComplete
          });
        }
        localStorage.setItem('codecollab-auto-complete', autoComplete);
        showNotification(`Auto complete ${autoComplete ? 'enabled' : 'disabled'}`, 'info');
      });

      // Theme Selection
      document.querySelectorAll('.theme-option').forEach(option => {
        option.addEventListener('click', function() {
          const theme = this.getAttribute('data-theme');
          
          // Update active theme
          document.querySelectorAll('.theme-option').forEach(opt => opt.classList.remove('active'));
          this.classList.add('active');
          
          // Apply theme to editor
          if (editor && typeof monaco !== 'undefined') {
            monaco.editor.setTheme(theme);
          }
          
          // Save theme preference
          localStorage.setItem('codecollab-editor-theme', theme);
          showNotification(`Theme changed to ${this.querySelector('.theme-name').textContent}`, 'success');
        });
      });

      // Toggle performance mode
      document.getElementById('toggle-performance').addEventListener('click', function() {
        performanceMode = !performanceMode;
        localStorage.setItem('codecollab-performance-mode', performanceMode);

        if (performanceMode) {
          document.body.classList.add('performance-mode');
          document.querySelector('.spline-container').style.display = 'none';
          document.querySelector('.gradient-bg').style.opacity = '1';
          document.querySelector('.gradient-bg').style.zIndex = '-1';
          showNotification('Performance mode enabled');
        } else {
          document.body.classList.remove('performance-mode');
          document.querySelector('.spline-container').style.display = 'block';
          document.querySelector('.gradient-bg').style.opacity = '0.3';
          document.querySelector('.gradient-bg').style.zIndex = '-2';
          showNotification('Performance mode disabled');
        }
      });

      // Room name editing (for room owner)
      const roomName = document.querySelector('.room-name');
      if (roomName.getAttribute('contenteditable') === 'true') {
        roomName.addEventListener('blur', function() {
          const newName = this.textContent.trim();
          if (newName && socket) {
            socket.emit('rename_room', {
              roomId,
              name: newName,
              userId
            });
          }
        });

        roomName.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            this.blur();
          }
        });
      }
    }

    // Toggle between light and dark mode
    function setupThemeToggle() {
      const themeToggle = document.getElementById('theme-toggle');
      const icon = themeToggle.querySelector('i');

      // Check for saved theme preference
      const savedTheme = localStorage.getItem('codecollab-theme');
      if (savedTheme === 'light') {
        document.body.classList.remove('dark-mode');
        icon.className = 'fas fa-moon';

        // Change editor theme
        monaco.editor.setTheme('vs');
      } else {
        // Default to dark mode
        document.body.classList.add('dark-mode');
        localStorage.setItem('codecollab-theme', 'dark');
        icon.className = 'fas fa-sun';

        // Ensure dark theme is applied to editor
        monaco.editor.setTheme('vs-dark');
      }

      themeToggle.addEventListener('click', function() {
        document.body.classList.toggle('dark-mode');

        if (document.body.classList.contains('dark-mode')) {
          icon.className = 'fas fa-sun';
          localStorage.setItem('codecollab-theme', 'dark');

          // Change editor theme
          monaco.editor.setTheme('vs-dark');
        } else {
          icon.className = 'fas fa-moon';
          localStorage.setItem('codecollab-theme', 'light');

          // Change editor theme
          monaco.editor.setTheme('vs');
        }
      });
    }

    // Helper function to close modals
    function closeModal(modalId) {
      console.log('Attempting to close modal:', modalId);
      const modal = document.getElementById(modalId);
      if (modal) {
        console.log('Modal found, removing show class');
        modal.classList.remove('show');
        document.body.style.overflow = 'auto';
      } else {
        console.error('Modal not found:', modalId);
      }
    }

    // Helper function to load current settings from localStorage
    function loadCurrentSettings() {
      console.log('Loading current settings...');
      try {
        // Load and apply saved settings
        const showCursors = localStorage.getItem('codecollab-show-cursors') !== 'false';
        const showCursorsEl = document.getElementById('setting-show-cursors');
        if (showCursorsEl) showCursorsEl.checked = showCursors;

        const autoSave = localStorage.getItem('codecollab-auto-save') !== 'false';
        const autoSaveEl = document.getElementById('setting-auto-save');
        if (autoSaveEl) autoSaveEl.checked = autoSave;

        const lineNumbers = localStorage.getItem('codecollab-line-numbers') !== 'false';
        const lineNumbersEl = document.getElementById('setting-line-numbers');
        if (lineNumbersEl) lineNumbersEl.checked = lineNumbers;

        const minimap = localStorage.getItem('codecollab-minimap') !== 'false';
        const minimapEl = document.getElementById('setting-minimap');
        if (minimapEl) minimapEl.checked = minimap;

        const realtimeSync = localStorage.getItem('codecollab-realtime-sync') !== 'false';
        const realtimeSyncEl = document.getElementById('setting-realtime-sync');
        if (realtimeSyncEl) realtimeSyncEl.checked = realtimeSync;

        const chatNotifications = localStorage.getItem('codecollab-chat-notifications') !== 'false';
        const chatNotificationsEl = document.getElementById('setting-chat-notifications');
        if (chatNotificationsEl) chatNotificationsEl.checked = chatNotifications;

        const joinAlerts = localStorage.getItem('codecollab-join-alerts') !== 'false';
        const joinAlertsEl = document.getElementById('setting-join-alerts');
        if (joinAlertsEl) joinAlertsEl.checked = joinAlerts;

        const performanceMode = localStorage.getItem('codecollab-performance-mode') === 'true';
        const performanceModeEl = document.getElementById('setting-performance-mode');
        if (performanceModeEl) performanceModeEl.checked = performanceMode;

        const autoComplete = localStorage.getItem('codecollab-auto-complete') !== 'false';
        const autoCompleteEl = document.getElementById('setting-auto-complete');
        if (autoCompleteEl) autoCompleteEl.checked = autoComplete;

        // Load theme
        const savedEditorTheme = localStorage.getItem('codecollab-editor-theme') || 'vs-dark';
        document.querySelectorAll('.theme-option').forEach(opt => opt.classList.remove('active'));
        const activeTheme = document.querySelector(`[data-theme="${savedEditorTheme}"]`);
        if (activeTheme) {
          activeTheme.classList.add('active');
        }

        console.log('Settings loaded successfully');
      } catch (error) {
        console.error('Error loading settings:', error);
      }
    }

    // Enhanced addChatMessage function with notifications
    function addChatMessage(data, isOwnMessage) {
      const { username, message, timestamp, picture } = data;
      const time = new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${isOwnMessage ? 'outgoing' : 'incoming'} mb-2`;

      messageDiv.innerHTML = `
        ${!isOwnMessage ? `<div class="message-sender">${username}</div>` : ''}
        <div class="message-content">${message}</div>
        <div class="message-time">${time}</div>
      `;

      const chatMessages = document.getElementById('chat-messages');
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;

      // Show notification if chat is closed and notifications are enabled
      const chatSidebar = document.getElementById('chat-sidebar');
      const chatNotificationsEnabled = localStorage.getItem('codecollab-chat-notifications') !== 'false';
      
      if (!isOwnMessage && !chatSidebar.classList.contains('open') && chatNotificationsEnabled) {
        showNotification(`${username}: ${message}`, 'info', 5000);
      }
    }

    // AI Chat Functions
    function initializeAIChat() {
      console.log('Initializing AI Chat...');
      
      // AI Model selector
      const aiModelSelect = document.getElementById('ai-model-select');
      if (aiModelSelect) {
        aiModelSelect.value = currentAIModel;
        aiModelSelect.addEventListener('change', function() {
          currentAIModel = this.value;
          console.log('AI Model changed to:', currentAIModel);
          showNotification(`Switched to ${this.options[this.selectedIndex].text}`, 'info', 2000);
        });
      }

      // AI Chat input
      const aiChatInput = document.getElementById('ai-chat-input');
      const aiSendBtn = document.getElementById('ai-send-message');
      
      if (aiChatInput) {
        // Auto-resize textarea
        aiChatInput.addEventListener('input', function() {
          this.style.height = 'auto';
          this.style.height = Math.min(this.scrollHeight, 120) + 'px';
        });

        // Send message on Enter (Shift+Enter for new line)
        aiChatInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendAIMessage();
          }
        });
      }

      if (aiSendBtn) {
        aiSendBtn.addEventListener('click', sendAIMessage);
      }

      // AI Action buttons
      const analyzeBtn = document.getElementById('ai-analyze-code');
      const debugBtn = document.getElementById('ai-debug-code');
      const optimizeBtn = document.getElementById('ai-optimize-code');
      const explainBtn = document.getElementById('ai-explain-code');

      if (analyzeBtn) {
        analyzeBtn.addEventListener('click', () => analyzeCurrentCode('general'));
      }
      
      if (debugBtn) {
        debugBtn.addEventListener('click', () => analyzeCurrentCode('debug'));
      }
      
      if (optimizeBtn) {
        optimizeBtn.addEventListener('click', () => analyzeCurrentCode('optimize'));
      }
      
      if (explainBtn) {
        explainBtn.addEventListener('click', () => analyzeCurrentCode('explain'));
      }

      // Initialize usage counter
      updateAIUsageCounter();

      console.log('AI Chat initialized successfully');
    }

    async function sendAIMessage() {
      const aiChatInput = document.getElementById('ai-chat-input');
      const message = aiChatInput.value.trim();
      
      if (!message || isAIResponding) return;

      // Add user message to chat
      addAIMessage(message, 'user');
      aiChatInput.value = '';
      aiChatInput.style.height = 'auto';

      // Show loading
      showAILoading();
      isAIResponding = true;

      try {
        // Get current code context
        const context = getCodeContext();
        
        const response = await fetch('/api/ai-chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: message,
            context: context,
            model: currentAIModel,
            conversationHistory: aiConversationHistory
          })
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          
          if (response.status === 429) {
            // Daily limit reached
            const message = errorData.requiresPro 
              ? 'ðŸ”’ You\'ve reached your daily AI chat limit (5 messages/day). Upgrade to Pro for unlimited access!'
              : 'You\'ve reached your daily AI chat limit. Please try again tomorrow.';
            addAIMessage(message, 'assistant', true);
            
            if (errorData.requiresPro) {
              showNotification('Daily AI limit reached! Upgrade to Pro for unlimited access', 'warning', 8000);
              setTimeout(() => showProUpgradeModal('ai-chat-limit'), 2000);
            } else {
              showNotification('Daily AI limit reached. Try again tomorrow.', 'warning', 5000);
            }
            return;
          } else {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
        }

        const data = await response.json();
        
        // Update usage counter if available
        if (data.usage && data.usage.remaining !== undefined) {
          aiUsageRemaining = data.usage.remaining;
          updateAIUsageCounter();
        }
        
        // Add AI response to chat
        addAIMessage(data.response, 'assistant');
        
        // Update conversation history
        aiConversationHistory.push(
          { role: 'user', content: message },
          { role: 'assistant', content: data.response }
        );

        // Keep only last 20 messages to manage memory
        if (aiConversationHistory.length > 20) {
          aiConversationHistory = aiConversationHistory.slice(-20);
        }

      } catch (error) {
        console.error('AI Chat error:', error);
        
        // Handle specific error types
        if (error.message.includes('403') || error.message.includes('Forbidden')) {
          addAIMessage('ðŸ”’ AI Chat requires a Pro subscription. Please upgrade to access this feature.', 'assistant', true);
          showNotification('AI Chat requires Pro subscription. Click here to upgrade!', 'warning', 8000);
        } else if (error.message.includes('401') || error.message.includes('Unauthorized')) {
          addAIMessage('Please sign in to use AI Chat features.', 'assistant', true);
          showNotification('Please sign in to access AI features', 'warning');
        } else {
          addAIMessage('Sorry, I encountered an error. Please try again.', 'assistant', true);
          showNotification('AI Chat error: ' + error.message, 'error');
        }
      } finally {
        hideAILoading();
        isAIResponding = false;
      }
    }

    async function analyzeCurrentCode(analysisType) {
      if (!editor || isAIResponding) return;

      const code = editor.getValue();
      if (!code.trim()) {
        showNotification('No code to analyze', 'warning');
        return;
      }

      // Show loading
      showAILoading();
      isAIResponding = true;

      try {
        const response = await fetch('/api/ai-analyze', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            code: code,
            language: currentLanguage,
            analysisType: analysisType
          })
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          
          if (response.status === 429) {
            // Daily limit reached
            const message = errorData.requiresPro 
              ? 'ðŸ”’ You\'ve reached your daily AI usage limit (5 requests/day). Upgrade to Pro for unlimited access!'
              : 'You\'ve reached your daily AI usage limit. Please try again tomorrow.';
            addAIMessage(message, 'assistant', true);
            
            if (errorData.requiresPro) {
              showNotification('Daily AI limit reached! Upgrade to Pro for unlimited access', 'warning', 8000);
              setTimeout(() => showProUpgradeModal('ai-analyze-limit'), 2000);
            } else {
              showNotification('Daily AI limit reached. Try again tomorrow.', 'warning', 5000);
            }
            return;
          } else {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
        }

        const data = await response.json();
        
        // Update usage counter if available
        if (data.usage && data.usage.remaining !== undefined) {
          aiUsageRemaining = data.usage.remaining;
          updateAIUsageCounter();
        }
        
        // Add analysis to chat
        const analysisTitle = {
          'general': 'ðŸ” Code Analysis',
          'debug': 'ðŸ› Debug Analysis', 
          'optimize': 'âš¡ Optimization Suggestions',
          'explain': 'ðŸ“ Code Explanation'
        }[analysisType] || 'ðŸ” Analysis';

        addAIMessage(`${analysisTitle}\n\n${data.analysis}`, 'assistant');

      } catch (error) {
        console.error('AI Analysis error:', error);
        
        // Handle specific error types
        if (error.message.includes('403') || error.message.includes('Forbidden')) {
          addAIMessage('ðŸ”’ AI Code Analysis requires a Pro subscription. Please upgrade to access this feature.', 'assistant', true);
          showNotification('AI Analysis requires Pro subscription. Click here to upgrade!', 'warning', 8000);
        } else if (error.message.includes('401') || error.message.includes('Unauthorized')) {
          addAIMessage('Please sign in to use AI Analysis features.', 'assistant', true);
          showNotification('Please sign in to access AI features', 'warning');
        } else {
          addAIMessage('Sorry, I encountered an error analyzing your code. Please try again.', 'assistant', true);
          showNotification('AI Analysis error: ' + error.message, 'error');
        }
      } finally {
        hideAILoading();
        isAIResponding = false;
      }
    }

    function addAIMessage(message, role, isError = false) {
      const aiChatMessages = document.getElementById('ai-chat-messages');
      const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      const messageDiv = document.createElement('div');
      messageDiv.className = `ai-message ${role}`;

      const iconClass = role === 'user' ? 'fas fa-user' : 'fas fa-robot';
      const formattedMessage = formatAIMessage(message);

      messageDiv.innerHTML = `
        <div class="ai-message-icon">
          <i class="${iconClass}"></i>
        </div>
        <div class="ai-message-content">
          <div class="ai-message-text ${isError ? 'error' : ''}">${formattedMessage}</div>
        </div>
      `;

      aiChatMessages.appendChild(messageDiv);
      aiChatMessages.scrollTop = aiChatMessages.scrollHeight;
    }

    function formatAIMessage(message) {
      // Convert markdown-style formatting to HTML
      return message
        .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/\n/g, '<br>');
    }

    function showAILoading() {
      const aiChatMessages = document.getElementById('ai-chat-messages');
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'ai-message ai-assistant';
      loadingDiv.id = 'ai-loading-message';

      loadingDiv.innerHTML = `
        <div class="ai-message-icon">
          <i class="fas fa-robot"></i>
        </div>
        <div class="ai-message-content">
          <div class="ai-message-text">
            <div class="ai-loading">
              <span>Thinking</span>
              <div class="ai-loading-dots">
                <div class="ai-loading-dot"></div>
                <div class="ai-loading-dot"></div>
                <div class="ai-loading-dot"></div>
              </div>
            </div>
          </div>
        </div>
      `;

      aiChatMessages.appendChild(loadingDiv);
      aiChatMessages.scrollTop = aiChatMessages.scrollHeight;
    }

    function hideAILoading() {
      const loadingMessage = document.getElementById('ai-loading-message');
      if (loadingMessage) {
        loadingMessage.remove();
      }
    }

    function getCodeContext() {
      if (!editor) return null;

      const selection = editor.getSelection();
      const selectedText = selection ? editor.getModel().getValueInRange(selection) : null;
      
      return {
        code: editor.getValue(),
        language: currentLanguage,
        selectedText: selectedText,
        fileIndex: currentFileIndex,
        fileName: files[currentFileIndex]?.name
      };
    }

    // Initialize AI Chat when document is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Add a small delay to ensure all elements are ready
      setTimeout(initializeAIChat, 1000);
    });
  </script>
</body>
</html>
